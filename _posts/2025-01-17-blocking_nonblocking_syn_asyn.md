---
title: "💬Blocking/non-Blocking, Syn/Asyn"
date: 2025-01-17 15:45 +0900
categories: [CS]
tags: [blocking, non-blocking, synchronus, asynchronus]
---

> 개발자는 "블로킹", "논블로킹, "동기", "비동기" 라는 용어를 자주 접하게 됩니다. 이 개념들은 프로그램의 실행 방식과 성능에 큰 영향을 미치는 중요한 요소들입니다. 하지만 이들 간의 차이점을 정확히 이해하고 구분하는 것은 쉽지 않습니다. 이 글에서 이 네 가지 개념을 설명하고, 각각의 특징과 차이점에 대해 알아보겠습니다.

`동기/비동기` 와 `블로킹/논블로킹` 이 두 개념은 비슷해 보이지만 관점이 다르다. `동기/비동기`는 작업의 완료 여부와 순서에 초점을 맞추는 반면, `블로킹/논블로킹`은 제어권의 이동에 초점을 맞춥니다. 정리하자면 다음과 같습니다. 

- **동기**: 작업의 완료 여부를 계속 확인하며, 작업이 순차적으로 실행됩니다. 
- **비동기**: 작업의 완료 여부를 신경 쓰지 않고, 다른 작업을 병렬적으로 실행할 수 있습니다. 

<br>

- **블로킹**: 작업을 요청한 함수가 제어권을 넘기고, 작업이 완료될 때까지 대기합니다.
- **논블로킹**: 작업을 요청한 함수가 제어권을 유지하며, 다른 작업을 계속 수행할 수 있습니다. 

이렇게만 보면 이해하기가 어려워 보인다. 각각 살펴보면서 알아보겠습니다.

## Blocking & Non-Blocking

블로킹과 논블로킹은 제어권의 이동에 초점을 맞추는 것이라고 했습니다. 이를 좀더 쉽게 표현하자면 특정 작업이 완료될 때까지 진행 중인 프로그램의 실행을 멈추냐 안 멈추냐로 생각하시면 되겠습니다. 여기서 블로킹은 요청한 작업이 완료될 때까지 대기하는 방식이고, 논블로킹은 요청만 하고 즉시 제어권을 받아 작업을 수행할 수 있습니다.

![blocking_nonblocking_movement.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/blocking_nonblocking_movement.png?raw=true)

위 그림을 보시면 블로킹은 프로세스B에게 작업을 요청하면 제어권이 프로세스 B에게 갑니다. 프로세스A는 프로세스B가 작업을 완료할 때까지 대기하고 기다립니다. 작업이 완료되면 요청값과 함께 제어권을 받아 다시 원래 하던 작업을 진행합니다.

그에 반해, 논블로킹 방식은 작업을 요청한 순간 작업의 완료 여부와 관계없이 즉시 제어권을 돌려받아, 다른 작업을 계속 수행할 수 있습니다. 

정리하자면, 블로킹은 **"요청받은 작업을 다 끝낼 때까지"** 대기하는 방식이고, 논블로킹은 **"요청한 작업을 하는 것을 다 끝날 때까지 기다리지 않고"** 즉시 제어권을 돌려받아 다른 작업을 수행할 수 있는 방식입니다.

이렇게 보면 블로킹을 사용할 이유가 없어 보입니다. 하지만 블로킹은 작업의 순서가 중요한 경우 또는 동시에 실행되는 작업의 수를 제한할 때 사용합니다. 따라서 시스템의 요구사항, 성능 목표, 개발 복잡성 등을 고려하여 블로킹과 논블로킹 방식을 적절히 선택하고 조합하는 것이 중요합니다. 특히 I/O 작업이 많은 환경에서 논블로킹이 유리할 수 있지만, 간단한 앱이나 CPU 집약적인 작업에서는 블로킹 방식이 더 적합할 수 있습니다.


## Synchronus & Asynchronous

동기와 비동기는 작업의 완료 여부와 순서에 초점을 맞춘다고 했습니다. 요청 작업을 순차적으로 하는지 안 하는지로 생각하시면 될 것 같습니다. 동기 방식은 요청을 하고 자기의 순번을 기다리는 방식이고, 비동기 방식은 요청 처리하는 곳이 많아 순서에 상관 없이 요청을 받으면 바로 시작할 수 있는 방식입니다. 

![syn_asyn_movement.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/syn_asyn_movement.png?raw=true)

위 그림을 보시면 동기 방식은 한 작업이 완료될 때까지 다음 작업은 대기하며, 모든 작업은 들어온 순서대로 진행됩니다. 그에 반해, 비동기 처리는 여러 작업을 동시에 처리할 수 있는 방식입니다. 한 작업의 완료를 기다리지 않고 실행할 수 있습니다. 비동기 방식에서 요청을 받는 곳이 여러 곳이기에 동시에 처리할 수 있다고 생각하셨다면 잘못된 생각입니다. 비동기 방식은 리소스의 양보다는 작업 처리 방식과 프로그램의 설계에 더 밀접합니다.

## 동기/비동기 + 블로킹/논블로킹 조합

블로킹/논블로킹과 동기/비동기는 서로 다른 개념이지만 조합하여 사용할 수 있습니다. 총 4가지가 있으며 이에 대해 설명하겠습니다.

### 동기 블로킹 (Synchronous Blocking)

동기 블로킹은 블로킹의 요청이 끝날 때까지 대기하는 방식과 동기의 다른 요청이 끝나 자신의 순번이 오면 처리하는 방식을 합친 방식입니다. 

![syn_blocking.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/syn_blocking.png?raw=true)

위 그림은 아까 블로킹 설명할 때 사용했던 그림에서 조금 추가했습니다. 이는 동기 블로킹과 일반 블로킹은 매우 유사한 특성을 보입니다. 둘 다 작업이 완료될 때까지 다음 작업으로 넘어가지 않는다는 공통점이 있습니다. 다만, 동기 블로킹은 블로킹의 특성을 포함하지만, 작업의 순차적 실행과 완료 여부를 더 강조합니다. 예를 들어 A(10), B(3)이 5초 간격으로 들어왔다면 A는 요청이 끝날 때까지 기다리는게 블로킹 방식이 맞지만 B는 A의 요청이 끝나는 시간까지 기다려야 합니다. 

이러한 동기 블로킹 방식은 간단한 애플리케이션이나 순차적 처리가 중요한 경우에 유용할 수 있지만 리소스 측면에서 비효율적이기 때문에 성능을 잘 생각하고 사용해야 합니다.

### 동기 논블로킹 (Synchronous Non-Blocking)

동기 논블로킹은 논블로킹의 요청이 끝나지 않아도 자신의 작업을 수행하는 방식과 동기의 자신의 순번이 오면 처리하는 방식을 합친 방식입니다.

![syn_nonblocking.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/syn_nonblocking.png?raw=true)

위 그림은 논블로킹 그림에서 동기 특징을 추가한 것이라 보시면 됩니다. 논블로킹 특성으로 인해 프로세스A가 요청을 보내도 즉시 제어권을 가져와 다른 작업을 수행할 수 있습니다. 여기에 프로세스A는 B의 작업 완료 여부를 지속적으로 확인하는 동기적 특성을 가집니다. 마지막 동기적 특성을 더 풀어서 설명하자면 CPU를 효율적으로 사용할 수 있게 해주지만, 동시에 A 함수가 B 함수의 완료를 계속해서 확인해야 하는 부분이 작업의 순서와 완료 여부를 중요시 여기는 동기적 특성입니다. 

이러한 동기 논블로킹 방식은 지속적으로 작업은 수행하면서도 다른 작업의 상태를 주기적으로 확인하는 폴링 시스템에서 많이 활용합니다. 이외에도 작업의 순서를 유지하면서도 시스템 자원을 효율적으로 사용할 수 있는 방식이기에 I/O 작업이 많은 환경에서 유용하게 사용될 수 있습니다. 

### 비동기 논블로킹 (Asynchronous Non-Blocking)

비동기 논블로킹 방식은 논블로킹의 요청이 끝나지 않아도 자신의 작업을 수행하는 방식과 비동기의 순번에 상관없이 처리하는 방식을 합친 방식입니다. 순서에 상관없이 여러 작업을 동시에 수행할 수 있어 전체적인 처리 속도가 향상됩니다.

자신의 작업을 실행한 채로 요청을 보낸다. 다수의 요청이 온 경우에도 동시에 처리할 수 있지만 요청이 종료되는 시점은 다를 수 있어도 상관없는 곳에서 사용됩니다. 대표적으로 네트워크 프로크에밍에서 대규모 네트워크 요청 처리로 많은 동시 연결을 효율적으로 관리하거나, 데이터 스트리밍에서 실시간 데이터를 대량의 데이터를 지속적으로 처리하고 표시하는 데 사용합니다.

### 비동기 블로킹 (Asynchronous Blocking)

비동기 블로킹은 프로그래밍에서 상대적으로 드물게 사용되는 방식입니다. 왜냐하면 비동기의 많은 요청을 동시에 처리하는 방식으로 진행하여 요청에 대한 처리가 빠르게 처리하지만 결과를 기다리는 동안 대기하므로 시스템의 자원을 효율적으로 사용하지 못하게 만듭니다. 즉, 비동기의 장점(동시처리)는 가져오지만 블로킹의 단점(자원 낭비)을 동시에 가지고 있습니다. 

때문에 비동기 블로킹은 이론적으로는 존재하지만, 실제 프로그래밍에서는 비동기 논블로킹 방식이 더 선호됩니다. 비동기 논블로킹 방식은 작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있어, 시스템 자원을 더 효율적으로 사용할 수 있습니다. 

그래서 비동기 블로킹은 특수한 상황에서 이루어집니다. 일부 운영 체제의 시스템 콜은 비동기적으로 호출되지만 결과를 기다리는 동안 프로세스를 블로킹하는 경우와 멀티 스레딩 환경에서 한 스레드에서 비동기 작업을 시작하고 다른 스레드에서 그 결과를 기다리는 경우, 비동기 블로킹 패턴이 나타나는 경우가 있습니다. 

## 마치며 

이 글에서는 블로킹/논블로킹과 동기/비동기의 개념을 살펴보고, 이들의 조합에 대해 알아보았습니다. 이러한 개념들은 프로그램의 실행 방식과 성능에 큰 영향을 미치는 중요한 요소입니다.

주요 개념 정리
- 블로킹: 작업이 완료될 때까지 제어권을 넘기고 대기
- 논블로킹: 작업 완료 여부와 관계없이 즉시 제어권을 돌려받음
- 동기: 작업의 순서와 완료 여부를 중요시하며 순차적으로 실행
- 비동기: 작업의 순서에 구애받지 않고 병렬적으로 실행 가능

조합의 특징
- 동기 블로킹: 가장 단순하지만 리소스 사용이 비효율적
- 동기 논블로킹: 작업 순서 유지하면서 자원 효율적 사용 가능
- 비동기 논블로킹: 높은 처리 속도와 효율성, 복잡한 시스템에 적합
- 비동기 블로킹: 이론적으로 존재하나 실제 사용은 드묾

프로그래밍에서 이러한 개념들을 정확히 이해하고 적절히 활용하는 것은 매우 중요합니다. 각 방식은 고유의 장단점을 가지고 있으며, 시스템의 요구사항, 성능 목표, 개발 복잡성 등을 고려하여 적절한 방식을 선택해야 합니다. 특히 I/O 작업이 많은 환경, 대규모 네트워크 애플리케이션, 실시간 데이터 처리 등 다양한 상황에서 이러한 개념들의 조합을 효과적으로 활용할 수 있습니다.
개발자로서 이러한 개념들을 깊이 이해하고 실제 상황에 적용할 수 있는 능력을 갖추는 것이 중요합니다. 이를 통해 더 효율적이고 성능이 뛰어난 시스템을 설계하고 구현할 수 있을 것입니다.