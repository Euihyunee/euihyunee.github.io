---
title: 💬GraphQL란?(작성중)
date: 2025-01-02 15:21 +0900
categories: [CS]
tags: [GraphQL, REST API]
---

![graphql_logo](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/graphql_logo.png?raw=true)

## GraphQL이란 무엇인가?

GraphQL은 클라이언트가 애플리케이션 프로그래밍 인터페이스(API)와 상호 작용하는 방식을 지정하는 오픈 소스 쿼리 언어(데이터 질의 언어)(Query + Schema)이자 서버 측 런타임입니다.

GraphQL 쿼리의 주요 개념 중 하나는 반환되는 데이터를 예측할 수 있다는 것입니다. 여분의 코드 문자열이 아니라 정확히 요청된 데이터만 반환됩니다. 이러한 선언적 데이터 가져오기는 대역폭이 제한된 모바일 디바이스에서 특히 유용합니다. 또한, 단일 요청으로 여러 데이터 항목을 한 번에 가져올 수 있어 네트워크 연결 속도가 느린 경우에도 빠르게 처리됩니다.

GraphQL은 페이스북에서 만든 API를 위한 쿼리 언어라고 할 수 있습니다. 같은 쿼리 언어인 SQL과 비교해보면 서로 목적부터 다릅니다.

GraphQL은 웹 클라이언트가 데이터를 서버로부터 효율적으로 가져오는 것이 목적인 쿼리 언어이고,
SQL은 데이터베이스 시스템에 저장된 데이터를 효율적으로 가져오는 것이 목적인 쿼리 언어입니다.
GraphQL은 타입 시스템을 사용하여 쿼리를 실행하는 서버사이드 런타임이며,
특정 데이터베이스나 플랫폼에 종속적이지 않습니다.

GraphQL에서는 요청한 필드만 반환되므로 over-fetching을 줄여 효율적입니다. 또한, GraphQL은 스키마를 사용하여 데이터 모델을 정의하기 때문에 클라이언트와 서버 간의 일관성 있는 데이터 통신을 보장합니다.


```
사용자 기반이 증가하고 모바일 앱 환경이 점점 더 복잡해짐에 따라 필요한 모든 쿼리 데이터를 가져오기 위해 여러 엔드포인트를 여러 번 왕복해야 했던 기존의 RESTful 접근 방식은 더 이상 지속가능하지 않게 되었습니다. 
```

### REST API와의 차이점 

```
REST 및 RESTful API는 복잡한 데이터 기반 사용자 인터페이스를 처리하는 데 적합하지 않았으며, 특히 데이터 요금제가 제한적이거나 비싼 모바일 사용자의 경우 지연 문제가 자주 발생하여 데이터 비효율성을 종종 겪고는 했습니다. 

URL 엔드포인트
- REST API는 URL + METHOD를 조합하기 때문에 정말 다양한 엔드포인트가 존재한다. 
- GraphQL는 단 하나의 엔드포인트(POST)만 가지고 쿼리 조합을 통해 데이터를 요청한다.  

response 데이터 
- REST API의 경우 return 되는 response 데이터가 정해져 있다. 그렇기 때문에 이전 API response에 다른 컬럼들이 추가되면 해당 파일을 계속 수정해줘야하고, API 별로 response가 다 다르면 그에 따른 DTO를 각각 다 만들어줘야 한다. 
- GraphQL는 쿼리로 요청하기 때문에 클라이언트가 원하는 데이터를 가져와 정제해서 사용할 수 있다. 

REST와 GraphQL은 모두 JSON 형식의 응답을 반환하지만 GraphQL은 데이터 간소화 및 통합에 중점을 둡니다. 
 
 캐싱 
 - REST API는 [GET]을 사용할 경우 캐싱이 가능하다. 
 - GraphQL은 캐싱을 하기 위해서는 client 혹은 server 개발자가 따로 캐싱 처리를 해주어야 한다. 

Facebook 엔지니어들은 이러한 문제에 대응하기 위해 단일 페이지 애플리케이션 플랫폼인 React와 함께 GraphQL을 개발하여 2015년에 오픈 소스 솔루션으로 공개했습니다. 그리고 2018년, Facebook은 이 GraphQL 서비스를 AWS, Gastsby, Intuit, IBM 등의 회원사로 구성된 GraphQL 재단으로 이전했습니다. 
```
## GraphQL의 핵심 개념 

GraphQL은 특정 애플리케이션 아키텍처가 필요하지 않으며 여러 환경(통합 개발 환경[IDE] 포함)에 배포할 수 있고 기존 API관리 도구와 함께 또는 기존 REST API 위에서 사용할 수 있습니다. 

GraphQL 파이프라인(그림으로 나타낼 것)
: 서버 사이드 GraphQL 애플리케이션은 GraphQL로 작성된 쿼리를 입력으로 받아 쿼리를 처리한 결과를 다시 클라이언트로 돌려줍니다. HTTP API 자체가 특정 데이터베이스나 플랫폼에 종속적이지 않은 것처럼 마찬가지로 GraphQL 역시 어떤 특정 데이터베이스나 플랫폼에 종속적이지 않습니다. 심지어 네트워크 방식에도 종속적이지 않습니다. 일반적으로 GraphQL의 인터페이스 간 송수신은 네트워크 레이어 L7의 HTTP POST 메서드와 웹소켓 프로토콜을 활용합니다. 필요에 따라서는 얼마든지 L4의 TCP/UDP를 활용하거나 심지어 L2 형식의 이더넷 프레임을 활용할 수도 있습니다. 
- GraphQL Query
- Query Language Processor (Parse, Validate)
- GraphQL Resolver (implemented by you) : RDB / NoSQL
- Output (Json)

주요 용어 
- 객체 타입 : 
    - 데이터 모델의 객체 필드를 정의하는 데 사용됩니다. 예시로, 사용자 객체는 이름과 이메일 같은 필드를 가집니다. 
- 필드 : 
    - 쿼리를 실행할 때 GraphQL 서버가 검색할 수 있는 데이터 타입을 정의합니다. 필드는 일반적으로 객체 타입에 속하지만 때떄로 스칼라 타입으로 정의됩니다. 스칼라 타입에는 문자열, 정수, 부동 소수점 수, 불리언 값, ID 등이 포함됩니다. 
- 스키마 : (타입 시스템과 연동해서 다시 볼 필요)
    - 클라이언트가 쿼리할 수 있는 데이터를 보여주기 위해 API 개발자가 만든 스키마는 클라이언트가 요청할 수 있는 개체와 해당 개체의 특성을 나타내는 필드를 정의하는 개체 유형으로 구성됩니다. 
    - GraphQL은 모든 데이터 유형이 GraphQL 스키마 정의 언어(SDL)로 기록되는 강력한 유형 시스템을 사용합니다. 형식화된 스키마는 API에서 쿼리할 수 있는 데이터 유형은 물론 사용자가 사용할 수 있는 작업과 유형 간의 관계를 지정합니다. 즉, API의 기능과 클라이언트가 상호 작용할 수 있는 데이터의 형태를 정의합니다. 
- 쿼리 : 
    - GraphQL API의 쿼리에 대한 진입점을 정의합니다. 쿼리는 GraphQL 서버에서 데이터를 검색(조회)하는 데 사용됩니다. 
    - 쿼리는 스키마에 따라 유효성을 검사한 후 실행됩니다. GraphQL은 개체 유형을 정의하지 않으면 쿼리를 실행할 수 없습니다.
    - 데이터 쿼리는 클라이언트가 GraphQL 서버에 보내는 요청으로, 클라이언트가 가져올 데이터를 지정합니다. 쿼리가 들어오면 GraphQL은 스키마 정의에 대해 쿼리의 유효성을 검사하고 쿼리가 유효하다고 가정하면 실행합니다. 쿼리 구조는 일반적으로 응답 데이터의 구조를 반영하여 데이터 요구 사항을 명시적이고 예측 가능하게 만듭니다. 
- 처리기 : 
    - 각 스키마 필드에 연결된 처리기 함수는 API 실행 시 값을 생성하기 위해 호출됩니다. 처리기는 GraphQL의 중요한 아키텍처 구성 요소입니다. 
- 리졸버(Resolver) : 
    - 기존의 SQL은 데이터를 가져오기 위해서 SQL을 작성했습니다. 또한, 데이터베이스에는 데이터베이스 애플리케이션을 사용하여 데이터를 가져오는 구체적인 과정이 구현되어 있습니다. 그러나 GraphQL에서는 데이터를 가져오는 구체적인 과정을 직접 구현해야 합니다. GraphQL 쿼리문 파싱은 대부분의 GraphQL 라이브러리에서 처리를 하지만, GraphQL에서 데이터를 가져오는 구체적인 과정은 resolver가 담당하고, 이를 직접 구현해야 합니다. 예를 들어서,  리졸버를 통해 데이터를 데이터베이스에서 가져 올 수 있고, 일반 파일에서 가져 올 수 있고, 심지어 http, SOAP와 같은 네트워크 프로토콜을 활용해서 원격 데이터를 가져올 수 있습니다. 이러한 특성을 이용하면 legacy 시스템을  GraphQL 기반으로 바꾸는데 활용할 수 있습니다. 
    - 스키마의 각 필드는 데이터를 채우고 필드 집합에 대한 응답을 결정하는 리졸버의 지원을 받습니다. 리졸버는 데이터베이스, 클라우드 서비스 또는 거의 모든 다른 소스에서 데이터를 검색할 수 있으며, GraphQL 작업(예: 쿼리, 변경 또는 구독)을 데이터로 변환하기 위한 지침을 제공합니다. 
    - 쿼리 필드가 실행되면 시스템은 다음 값을 생성하기 위해 해당 리졸버에 대한 호출을 생성합니다. 필드가 스칼라 값(예: 문자열 또는 숫자)을 생성하는 경우 실행이 완료됩니다. 필드가 객체 값을 생성하는 경우 쿼리에는 해당 객체에 대한 필드가 더 포함됩니다. 이 프로세스는 스칼라 필드만 남을 때까지 계속됩니다. 
    - 또한 리졸버는 데이터 서식을 쉽게 지정하고 시스템이 다양한 데이터 소스의 정보를 연결할 수 있도록 도와줍니다. 
- 변이 (Mutation)
    - 변이는 서버에서 데이터를 생성, 업데이트, 삭제하는 GraphQL 작업입니다. 이는 RESTful API의 POST, PUT, PATCH 및 DELETE 작업과 유사합니다. 쿼리가 작동하는 방식과 유사하게 GraphQL 변이는 스키마와 해당 정의에 대해 유효성이 검사됩니다. 변이의 유효성이 검사되고 실행되면 서버는 JSON 응답을 반환합니다. 
    - GraphQL API의 변이에 대한 진입점을 정의합니다. 변이는 GraphQL 서버의 데이터를 변경하는 데 사용됩니다. 
- 구독 : GraphQL API에 구독하는 진입점을 정의합니다. 구독은 GraphQL 서버로부터 실시간 데이터 업데이트를 받는데 사용됩니다. 
- Scalar 
    - GraphQL은 Int, Float, String, Boolean, ID Type만을 지원하기 때문에 우리가 원하는 type을 사용하기 위해서는 Scalar를 선언해야만 한다. 
- 인트로스펙션(Introspection)
    - 기존 서버-클라이언트 협업 방식에서는 연동규격서라고 하는 API 명세서를 주고 받는 절차가 반드시 필요했습니다. 프로젝트 관리 측면에서 관리해야 할 대상의 증가는 작업의 복잡성 및 효율성 저해를 의미합니다. 이 API 명세서는 떄떄로 관리가 제대로 되지 않아, 인터페이스 변경 사항을 제때 문서에 반영하지 못하기도 하고, 제 타이밍에 전달 못하곤 합니다. 
    - 이러한 REST의 API 명세서 공유와 같은 문제를 해결하는 것이 GraphQL의 인스트로스펙션 기능입니다. GraphQL의 인트로스펙션은 서버 자체에서 현재 서버에 정의된 스키마의 실시간 정보를 공유할 수 있게 합니다. 이 스키마 정보만 알고 있으면 클라이언트 사이드에서는 따로 연동규격서를 요청할 필요가 없게 됩니다. 클라이언트 사이드에서는 실시간으로 현재 서버에서 정의하고 있는 스키마를 의심할 필요없이 받아들이고, 그에 맞게 쿼리문을 작성하면 됩니다. 
    - 인스트로스펙션용 쿼리는 따로 존재한다. 일단 GraphQL 쿼리문을 작성하듯이 작성하면 된다. 다만 실제로는 굳이 스키마 인트로스펙션을 위해 GraphQL 쿼리문을 작성할 필요가 없습니다. 대부분의 서버용 GraphQL 라이브러리에는 쿼리용 IDE를 제공합니다. 
    - 인스트로스펙션을 활용하면 직접 쿼리 및 뮤테이션, 필드 스키마를 확인할 수 있습니다. 보안상의 이슈로 상용환경에서는 이러한 스키마의 공개는 신중해야 합니다. 대부분의 라이브러리는 해당기능을 켜고 끄게 하는 옵션이 존재합니다. 


## GraphQL의 장단점 

오버페칭과 언더페칭 문제 해결
- REST 아키텍처에서 오버페칭은 빠르게 문제가 될 수 있습니다. 백엔드는 프론트엔드에 단일 요소만 필요한 경우에도 각 리소스에 사용할 수 있는 데이터를 정의하고 응답 시 모든 데이터를 반환합니다.
- GraphQL 호출은 단일 트립에서 이루어지며 오버페칭 없이 요청된 데이터를 클라이언트에게 제공합니다. 

신뢰할 수 있는 단일 소스(Single Source of Truth) 설정
- GraphQL 스키마는 GraphQL 애플리케이션에서 신뢰할 수 있는 단일 소스를 설정하여 모든 데이터가 설명되는 기본 위치를 제공합니다. GraphQL 스키마는 일반적으로 서버에서 정의되지만 클라이언트는 스키마에 따라 계속 데이터를 쿼리하고 쓸 수 있습니다. 

GraphQL은 단 하나의 데이터 소스를 사용하여 모든 데이터를 쿼리할 수 있습니다. 모든 요청은 단일 서버 엔드포인트에 접근할 수 있습니다.

- GraphQL의 응답은 클라이언트가 요청한 필드와 정확하게 일치하여 클라이언트와 서버 간의 간섭을 줄입니다. 
- GraphQL은 요청 시 매개변수 전송을 포함하여 모든 데이터 타입의 정의 및 전송을 지원합니다.
- GraphQL은 현재 많은 오픈 소스 도구 플랫폼, 플러그인 및 확장을 보유하고 있습니다. 

클라이언트와 서버 간의 향상된 통신
- 데이터 유형이 강력하게 정의되어 있기 때문에 클라이언트와 서버 간의 통신은 REST보다 GraphQL에서 훨씬 명확합니다. 또한 이러한 기본 구조는 GraphQL 서버를 호출하는 데 복잡한 클라이언트가 필요하지 않음을 의미합니다. 자세한 내용을 알아보고 실제 코드를 보려면 GraphQL 공식페이지에서 클라이어트 및 서버에 대해 읽어보십시오.   
HTTP 요청 횟수를 줄일 수 있다. 
- RESTful API의 경우 필요한 리소스 별로 요청해야 하고, 필요한 데이터들이 부분적으로 나눠서 개발되어 있다면 그만큼 요청횟수가 늘어난다. 하지만 GraphQL은 원하는 정보를 하나의 쿼리에 모두 담아 요청할 수 있다.  
HTTP 응답 사이즈를 줄일 수 있다. 
- RESTful API의 경우 응답의 형태가 정해져있기 때문에 필요한 정보만 부분적으로 요청하는 것이 힘들고, 자연스럽게 데이터의 사이즈가 클수 밖에 없다. GraphQL을 사용함으로써 응답 데이터 사이즈를 최소화하여 모바일 환경의 부담을 줄일 수 있다. 


연동을 통해 확장 가능 
- 설계 원칙과 도구의 집합인 API 연동은 제한된 컨텍스트 내의 서비스를 사용자에게 일관된 API로 노출하는 동시에 해당 컨텍스트 내의 서비스가 제한 없이 진화할 수 있도록 합니다. GraphQL은 전체 API를 연동하고 이전 쿼리를 중단하지 않고 발전시킨 후 확장하는 방법을 제공하며, 이러한 확장성은 많은 기업에서 GraphQL을 사용하는 이유 중 하나입니다. 

내성 특성 
- GraphQL의 내성적 특성 덕분에 GraphQL API에서 GraphQL 스키마를 가져올 수 있습니다. 또한 클라이언트가 사용 가능한 데이터 유형 목록을 요청할 수 있으므로 문서를 자동으로 생성하고 여러 마이크로서비스에서 스키마를 테스트하거나 가져오는 데 적합합니다. 

강력한 타입 시스템

단일 엔드포인트

실시간 업데이트를 위한 Subscription

프론트엔드와 백엔드 개발자의 부담을 덜 수 있다. 
- RESTful API를 사용한다면 프론트엔드 개발자는 API의 request/response 형식에 의존하게 된다. 따라서 새로운 엔드포인트를 효율적으로 개발하기 위해서는 프론트엔드와 백엔드 개발자의 커뮤니케이션이 강제되는 경우가 많았다. 하지만 GraphQL은 request/response 의존도가 덜 하기 때문에 개발자들의 API 개발 부담을 덜 수 있다. 

- 복잡한 데이터 구조를 가진 API 설계 : 복잡한 계층 데이터 구조를 가진 API 설계는 RESTful API에서 어려울 수 있습니다. 그러나 GraphQL는 클라이언트가 필요한 데이터 구조를 명확하게 정의할 수 있기 때문에 복잡한 데이터 구조를 가진 API 설계를 쉽게 만들어 줍니다. 
- 모바일 앱 및 단일 페이지 앱(SPA) 개발 : 모바일 앱과 SPA는 종종 여러 API 엔드포인트에서 데이터를 가져와야 합니다. 그러나 GraphQL을 사용하면 하나의 API 엔드포인트에서 필요한 데이터를 가져올 수 있어 네트워크 트래픽을 줄이고 성능을 개선합니다. 
- 프론트엔드와 백엔드 분리 : GraphQL은 프론트엔드와 백엔드를 분리할 수 있게 해주어 두 팀이 독립적으로 개발할 수 있도록 합니다. 이는 개발 과정을 가속화하고 팀 생산성을 향상시킵니다. 
- 사용자 정의 쿼리 및 인증 : GraphQL은 클라이언트가 필요한 데이터를 사용자가 정의할 수 있게 해줍니다. GraphQL은 또한 유연한 인증 및 권한 부여 기능을 제공하여 높은 보안이 필요한 애플리케이션에 적합합니다.

**단점**

GraphQL을 채택해야 하는 이유는 많지만 알아야할 몇 가지 단점도 있습니다. 예를 들어 모든 것을 즉시 사용할 수 있는 것은 아닌데, 다른 사람의 API를 사용하려면 특별한 라이브러리가 필요합니다. 그리고 전반적으로 GraphQL은 REST보다 더 많은 도구 지원이 필요합니다. 
- 고정된 요청과 응답만 필요할 때에는 query로 인해 요청의 크기가 RESTful API보다 커질 수 있다.
- 캐싱이 REST보다 복잡하다. 
- 파일 업로드 구현 방법이 정해져 있지 않아 직접 구현해야 한다. 

학습 곡선 
- REST API에 익숙한 개발자에게 GraphQL의 학습 곡선이 더 가파릅니다. 또한 워크플로가 변경될 수도 있는데, GraphQL을 사용하는 API 팀은 유지 관리 가능한 GraphQL 스키마도 작성해야 하기 떄문입니다. 하지만 새로 시작하는 경우에는 요청과 응답의 구조가 동일하므로 GraphQL을 쉽게 배우고 사용할 수 있습니다. 

고유한 API 관리 전략
- GraphQL은 새로운 API 관리 전략이 필요할 수 있는 반면, REST API는 기존 API관리 모델에 적합한 경향이 있습니다. 이는 중요하게 고려해야 하는데, 새로운 API 관리 전략을 추가하면 전체 비용이 증가할 수 있기 때문입니다.  
- 서버 개발자는 쉽게 유지 관리할 수 있는 데이터 모델을 개발하는 데 더 많은 시간을 할애해야 할 수 있습니다. 

복잡한 캐싱 
- 캐싱은 요청이 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)를 사용하는 REST보다 GraphQL에서 덜 간단합니다. 표준 GraphQL 요청은 HTTP 수준에서 캐시할 수 없는 POST입니다. 또한 단일 엔드포인트가 있다는 것은 엔드포인트의 URL이 캐시할 수 없는 여러 가지 다양한 응답을 생성(데이터 가져오기에는 적합하지만 캐싱에는 부적합)한다는 것을 의미하므로 GraphQL에서 캐싱이 복잡해질 수 있습니다. 그러면 서버 개발자는 동일한 개체 내에서 작동하더라도 서로 다른 쿼리를 사용하게 됩니다. 하지만 많은 GraphQL 라이브러리가 기본으로 캐싱 메커니즘을 제공하고 있다는 것은 분명한 사실입니다. 


## GraphQL의 고급 기능

```
페이지네이션

캐싱 전략

에러 처리

보안 고려사항 
```

## GraphQQL 도구와 생태계

```
GraphiQL과 Playground

Apollo 스택 소개

기타 유용한 라이브러리와 도구들 
```

## GraphQL 실제 사용 사례

```
대규모 서비스에서의 GraphQL 적용 예시 

마이크로서비스 아키텍처와 GraphQL
```

## 결론

```
GraphQL 도입 시 고려사항 

GraphQL은 장점은 퍼포먼스적인 장점과 생산성 향상이 있습니다. GraphQL은 기존 백엔드-프론트앤드 협업 문화를 많이 바꿀것으로 예상합니다. GraphQL의 협업 구조상 프론트앤드쪽에 조금 더 할일이 많아지고 힘이 실리는 느낌입니다. 에자일하게 웹사이트 프로젝트를 진행하는데 GraphQL이 많은 도움이 될 것이라고 생각합니다. 

GraphQL은 많은 공부없이는 실전에서 사용하기는 쉽지 않을 것입니다. 

REST API와의 공존 전략 

REST가 가지는 한계 떄문에 개발된 GraphQL이지만, GraphQL이 완벽하게 REST를 대체할 수는 없어보입니다. 
REST에 더 적합한 서비스에는 REST가 사용되는 것이 바람직하므로, GraphQL와 REST의 장단점을 파악해 서비스에 맞는 방식을 고르는 것이 중요하다. 
```