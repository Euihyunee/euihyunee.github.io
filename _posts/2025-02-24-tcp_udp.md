---
title: "💬 TCP와 UDP의 개념 feat. 흐름제어&혼잡제어"
date: 2025-02-24 10:43 +0900
categories: [CS]
tags: [Network, TCP, UDP, Flow Control, Congestion Control]
---

> TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 전송 계층에서 사용되는 주요 프로토콜입니다. 애플리케이션 계층과 네트워크 계층 사이에서 데이터 전송을 담당합니다. 이 글에서 TCP/UDP의 개념과 각각의 역활, 흐름 제어, 혼잡 제어 그리고 어떤 부분에서 활용되는지 알아보겠습니다.

## TCP란?

TCP(Transmission Control Protocol)는 신뢰성 있는 데이터를 위해 사용되는 프로토콜입니다. TCP 통신 과정은 크게 연결 수립, 데이터 전송, 연결 종료의 세 단계인로 나눌 수 있습니다. 각 과정에 대해 알아보겠습니다. 

### TCP 연결과정(3-way handshake)

TCP의 연결과정은 간단히 말해, 두 컴퓨터가 안전하게 데이터를 주고 받기 위한 사전 작업입니다. 서로를 인식하고, 상태를 확인하고, 합의하에 통신하는 것입니다. 이러한 과정의 목적은 두 컴퓨터가 안전하고 효율적으로 데이터를 주고받을 수 있는 연결을 통해 원활하게 데이터를 교환하기 위함입니다. 과정별로 설명하자면 다음과 같습니다. 

<style>
  .img_container_box {
    display: flex;
    flex-wrap: wrap;
  }
  .left-div-example, .right-div-example {
    flex: 1;
    min-width: 300px; /* 최소 너비 설정 */
  }
  .left-div-example img {
    width: 100%;
    height: auto;
    padding-right: 10px;
  }
  .right-div-example {
    padding-top: 10px;
  }
  @media (max-width: 768px) {
    .right-div-example {
      flex-basis: 100%;
      order: 2;
    }
  }
</style>

<div class="img_container_box">

  <div class="left-div-example">
    <img src="https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/tcp_behavior.png?raw=true" alt="tcp_behavior">
  </div>

  <div markdown="1" class="right-div-example">


1️⃣ **연결(SYN) 요청:**

- 클라이언트가 서버에 연결을 요청합니다.
- SYN(Synchronize)라는 패킷을 보내며, 이는 TCP 연결을 시작하는 신호로 사용됩니다.

2️⃣ **연결 승인(SYN-ACK):**

- 서버가 클라이언트의 연결 요청을 수락합니다.
- ACK(Acknowledgment)라는 패킷을 SYN과 함께 보내며, 연결 요청을 승인하고 서버가 연결을 시작할 준비가 되었음을 알리는 역할을 합니다.



</div>
</div>


3️⃣ 연결 확립(ACK):
- 클라이언트가 서버의 응답(SYN-ACK)을 확인하고 연결을 확립(`Established` 상태)합니다. 
- 서버도 클라이언트의 ACK를 받고 연결을 확립(`Established` 상태)합니다.

> `3-way handshake`이 끝나고 나면 클라이언트와 서버가 연결이 수립되어 실제 데이터 전송이 시작됩니다. 
{: .prompt-info }


### TCP 연결종료과정(4-way handshake)

`3-way handshake`이 끝나고 데이터 전송을 마친 후에는 연결을 해제해야 합니다. TCP 연결 종료 과정은 `4-way handshake`라고 불리며, FIN(Finish)와 ACK(Acknowledgement)를 사용합니다. 과정별로 설명하자면 다음과 같습니다.

<div class="img_container_box">
  <div class="left-div-example">
    <img src="https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/4_way_handshake.png?raw=true" alt="4_way_handshake">
  </div>
  <div markdown="1" class="right-div-example">

1️⃣ 연결 종료 요청(FIN):

- 클라이언트가 서버에 연결 종료를 요청합니다.
- FIN은 클라이언트가 더 이상 전송할 데이터가 없음을 알리는 패킷입니다.

2️⃣ 종료 요청 확인(ACK):

- 서버는 클라이언트(FIN) 종료 요청에 대해 ACK로 응답합니다.
- ACK는 서버가 클라이언트의 연결 종료 요청을 받았음을 확인하는 패킷입니다.

3️⃣ 서버 측 연결 종료(FIN):

- 서버가 남은 데이터를 모두 전송한 후 FIN 패킷을 클라이언트에게 전송합니다.
- FIN은 서버가 더 이상 전송할 데이터가 없으며, 연결을 종료할 준비를 마쳤다는 것을 알립니다.


</div>
</div>

4️⃣ 종료 확인(ACK):

- 클라이언트는 서버의 FIN에 대해 ACK로 응답합니다.
- ACK는 클라이언트가 서버 연결 종료 요청을 받았음을 확인하고, ACK를 서버에 전송합니다. 
- 클라이언트는 TIME_WAIT 상태로 들어갑니다. 대기 시간이 끝난 후에 클라이언트는 연결을 종료합니다.
- 클라이언트가 보낸 ACK를 받은 서버는 연결을 종료합니다.

> `TIME_WAIT`은 지연된 패킷이 새로운 연결에 영향을 주는 것을 방지하기 위해 사용합니다. 또한 마지막 ACK가 손실된 경우 재전송할 수 있는 기회를 제공합니다. ACK가 서버에 도달하지 않는다면 서버는 연결 종료를 하지 않는 것을 방지하기 위해 사용합니다.

이렇게 HTTP는 웹 브라우저와 웹 서버 간의 신뢰성 있는 데이터 전송을 위해 TCP 프로토콜을 사용합니다. 또한 HTTP에서 성능을 향상시키는 방법은 TCP에서 비롯된 것들이 많습니다(지속 연결, TCP 최적화, 버퍼 관리 등). 따라서 웹 개발에서 반드시 알아야하는 개념이라고 생각합니다.

### TCP 역활

이러한 TCP는 인터넷에서 데이터를 안정적으로 전송하기 위한 과정을 거칩니다. 다음과 같은 중요한 역활을 수행합니다.
    
#### 데이터 전송의 신뢰성 보장 

- 연결 지향적 통신: 데이터 전송 전 3-way handshaking을 통해 연결을 설정하고, 4-way handshaking으로 연결을 종료합니다.
- 오류 검출 및 재전송: 데이터 손실, 중복, 오류 발생 시 재전송을 수행하여 신뢰성을 확보합니다.
- 순서 보장: 데이터가 송신된 순서대로 수신되도록 보장합니다.

#### 네트워크 관리

- 흐름 제어: 수신자의 처리 속도에 맞춰 데이터 전송 속도를 조절하여 버퍼 오버플로우를 방지합니다.
- 혼잡 제어: 네트워크의 혼잡도를 감지하고 데이터 전송 속도를 조절하여 효율적인 통신을 유지합니다.

#### 데이터 처리 

- 세그먼트화: 대용량 데이터를 적절한 크기의 세그먼트로 분할하여 전송합니다.
- 재조립: 수신된 세그먼트를 원래의 데이터 스트림으로 재구성합니다.

#### 주소 지정 및 다중화

- 포트 번호 사용: 여러 애플리케이션의 데이터를 구분하고 적절히 전달합니다.


## TCP 흐름제어

TCP 흐름제어는 송신 측과 수신 측 사이의 데이터 전송 속도를 조절하는 메커니즘입니다. 주요 목적은 수신 측의 처리 능력을 초과하는 데이터 전송을 방지하기 위함입니다. UDP에는 흐름 제어 기능이 없으며 TCP에만 있는 기능입니다.

- 수신 측이 송신 측에게 자신의 상태를 지속적으로 알립니다.
- 수신 버퍼의 오버플로우를 방지합니다.
- 전송 계층과 데이터 링크 계층에서 처리됩니다.

흐름제어는 데이터 전송 과정에서 주로 사용되며, TCP 연결 과정에서는 초기 설정만 이루어집니다.

### Stop and Wait 흐름제어 방식

Stop and Wait 방식은 TCP 흐름제어의 가장 기본적인 형태로, 다음과 같은 특징을 가집니다.

<div class="img_container_box">

  <div class="left-div-example">
    <img src="https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/stop_and_wait.png?raw=true" alt="stop_and_wait">
  </div>

  <div markdown="1" class="right-div-example">

***동작 원리***

- 송신자가 하나의 패킷을 전송한 후 수신자의 확인 응답(ACK)을 기다립니다.
- 수신자는 패킷을 성공적으로 받으면 ACK를, 오류가 있으면 NAK(Negatice ACK)를 보냅니다.
- 송신자는 ACK를 받은 후에만 다음 패킷을 전송합니다.

이처럼 Stop and Wait 방식은 구현이 간단하고 이해하기 쉬우며 순차적 처리로 패킷 순서 문제가 발생하지 않습니다.  

하지만, 네트워크 자원 활용도가 낮고 효율성이 떨어지는 단점이 있습니다. 또한, 매 패킷마다 ACK를 기다려야 하므로 전송 지연이 발생합니다.

</div>
</div>


> NAK는 수신자가 데이터를 제대로 받지 못했거나 오류가 있음을 송신자에게 알리는 신호입니다. 주로 패킷 손실, 데이터 손상, 또는 기타 오류 상황에서 사용됩니다.
{: .prompt-info }


Stop and Wait 방식은 간단하지만 비효율적이어서, 대역폭이 큰 네트워크에서는 성능이 크게 저하될 수 있습니다. 이러한 단점을 보완하기 위해 `Sliding Window`와 같은 더 효율적인 흐름제어 기법이 개발되었습니다.

### Sliding Window 흐름 제어 방식

Slinding Window 방식은 Stop and Wait 방식을 보완한 기법으로 현대 TCP 구현에서 가장 널리 사용되는 흐름 제어 메커니즘입니다.

<div class="img_container_box">

  <div class="left-div-example">
    <img src="https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/sliding_window.png?raw=true" alt="sliding_window">
  </div>

  <div markdown="1" class="right-div-example">

***동작 원리***

1. 연결 설정 과정(3-way handshake) 중에 양쪽이 초기 윈도우 크기를 교환합니다.
2. 송신 측은 초기에 설정된 윈도우 크기만큼 데이터를 전송할 수 있습니다.
3. 수신 측은 데이터를 받은 후 자신의 버퍼 상태에 따라 윈도우 크기를 조정하여 ACK와 함께 송신 측에 알립니다.
4. 잘못된 데이터를 받은 경우 수신 측은 NAK 메시지에 오류가 발생한 패킷의 번호를 포함시켜 보냅니다.
5. 송신 측은 오류 패킷 번호부터 다시 재전송 합니다.

Sliding Window 방식은 수신 측이 윈도우 크기를 결정하고, 송신 측은 이 정보를 바탕으로 패킷을 전송합니다. 

덕분에 TCP의 특성인 신뢰성 있는 데이터 전송과 네트워크 대역폭의 최대 활용을 동시에 달성할 수 있게 해줍니다.

</div>
</div>

> NAK는 일부 프로토콜에서는 해당 패킷만 전송합니다. 또한 TCP에서는 일반적으로 NAK를 사용하지 않고, 중복 ACK나 SACK를 사용하여 구현합니다. 이 글에선 이해를 돕기 위해 NAK로 작성하였습니다.
{: .prompt-warning }

## TCP 혼잡제어

TCP 혼잡제어는 네트워크의 혼잡을 방지하고 효율적인 데이터 전송을 위해 사용되는 메커니즘입니다. 네트워크는 대역폭, 하드웨어, 트래픽, 네트워크 공격, 패킷 충돌 등의 이유로 성능 저하와 혼잡을 초래합니다. 여기에 혼잡제어를 활용하여 네트워크 상황에 따라 전송률을 조절하며, 효율적이고 안정적인 데이터 전송을 보장합니다.

TCP 혼잡제어는 주로 세 가지 구간에서 이루어집니다.

### 1. 슬로우 스타트(Slow Start)

- 연결 시작 또는 혼잡 발생 시 적용
- 동작
    - 혼잡 윈도우(CWND)를 1 MSS로 초기화
    - ACK 수신마다 CWND를 1 MSS씩 증가
    - 결과적으로 매 RTT마다 CWND가 2배씩 증가(지수적 증가)
- CWND가 슬로우 스타트 임계값(ssthresh)에 도달하면 종료 

> RTT(Round Trip Time)는 데이터 패킷이 송신자에서 수신자로 갔다가 다시 돌아오는 시간을 의미합니다. 여기에 CWND가 증가시키는 것은 네트워크 용량을 빠르게 파악하고 효율적으로 사용할 수 있게 해주는 중요한 매커니즘입니다.  
슬로우 스타트 임계값은 TCP가 슬로우 스타트 단계에서 혼잡 회피 단계로 전환하는 지점을 나타냅니다. 쉽게 말하자면 슬로우 스타트 단계에서는 빠르게 네트워크 상황을 파악할 수 있고, 임계값(ssthresh)부터는 네트워크가 혼잡해지기 전에 미리 속도를 조절하도록 돕는 역활을 합니다.
{: .prompt-info }

### 2. 혼잡 회피(Congestion Avoidance)

- 슬로우 스타트 이후 또는 CWND가 ssthresh에 도달했을 때 시작
- 동작
    - 매 RTT마다 CWND를 1 MSS씩 증가(선형적 증가)
    - ACK 수신마다 CWND를 1/CWND만큼 증가
- 네트워크 용량에 근접할 때까지 천천히 증가

혼잡 회피는 슬로우 스타트보다 천천히 CWND를 증가시킵니다. CWND는 비유하자면 입력량(데이터 양)입니다. 네트워크 입력을 급격하게 증가시키면 혼잡할 확률이 높으니 네트워크 상태 변화에 따라 점진적으로 속도를 올려 네트워크의 자원을 최대한 활용하면서 과도한 혼잡을 방지합니다. 

### 3. 빠른 회복(Fast Recovery)

- 3개의 중복 ACK 수신 시 적용(경미한 혼잡 상황)
- 동작
    - ssthresh를 현재 CWND의 1/2로 설정
    - 손실된 세그먼트 재전송
    - CWND를 ssthresh + 3 MSS로 설정
    - 중복 ACK 수신 시 CWND를 1 MSS씩 증가
    - 새로운 ACK 수신 시 CWND를 ssthresh로 설정하고 혼잡 회피로 전환

ssthresh는 비유하자면 처리량입니다. 네트워크가 혼잡할 시 가용할 수 있는 자원은 정해져 있으니 하나의 전송을 처리하기 위한 처리량과 입력량을 줄이는 것이라 생각하면 됩니다. 

`CWND = ssthresh + 3`은 네트워크에 데이터 입력을 처리하는 것보다 약간 더 높게 두어 혼잡에 대응하면서도 완전히 슬로우 스타트로 돌아가지 않고 적절한 전송 속도를 유지하는 것입니다. 입력이 처리하는 것보다 많아지는 것이 이해가 안 될 수 있습니다. 빠른 회복을 위해 입력과 처리에 대한 개별 데이터 가용 자원을 줄이면서 추후에 네트워크가 정상으로 돌아올 때를 대비해 일정 수준의 전송을 유지하는 것입니다. 이는 네트워크의 효율성과 안정성 사이의 균형을 유지하고, 일시적인 혼잡 상황에서도 빠르게 복구할 수 있는 유연성을 제공합니다.

## UDP란

UDP(User Datagram Protocol)는 TCP와 마찬가지로 전송 계층에서 작동하는 통신 프로토콜입니다. UDP의 가장 큰 특성 간단한 프로토콜입니다. TCP와 달리 연결 설정 없이 데이터를 전송합니다. 이로 이한 특징은 다음과 같습니다.

- 비연결성: UDP는 연결 설정(3-way handshake) 없이 데이터를 전송합니다. 
- 신뢰성 없음: 데이터 전달의 보장, 순서 보장, 중복 제거 등을 제공하지 않습니다.
- 데이터그램 지향: UDP는 독립적인 데이터 단위인 데이터그램을 사용하여 통신합니다.
- 빠른 속도: 연결 설정과 오류 제어 메커니즘이 없어 TCP보다 일반적으로 빠릅니다.
- 싱테 비저장: 연결 관련 정보를 유지하지 않습니다.
- 혼잡 제어 및 흐름 제어 없어 네트워크 상태와 관계없이 데이터를 전송합니다.
- 효율적인 리소스 사용: 낮은 오버헤드로 네트워크 리소스를 효율적으로 사용합니다.

### UDP 동작방식

UDP는 기본적으로 연결 설정이 필요하지 않습니다. 그래서 단순히 송신자가 목적지만 정해서 데이터를 전송하기만 하면 됩니다. 송신자는 목적지 IP 주소와 포트 번호만 지정하며, UDP 헤더에는 출발지 포트 번호, 목적지 포트 번호, 데이터그램의 길이가 포함되어 있으며 상황에 따라 체크섬을 추가할 수 있습니다.

![udp_behavior.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/udp_behavior.png?raw=true)

### UDP를 활용하는 분야 

UDP는 신뢰성보다는 속도와 효율성이 중요한 애플리케이션에서 핵심적인 역활을 수행합니다. 따라서 데이터 전달의 신뢰성이 중요하지 않으며, 빠른 속도가 필요한 곳에서 사용됩니다.

#### 실시간 애플리케이션

- 멀티미디어 스트리밍: 비디오 및 오디오 스트리밍 서비스에서 빠른 데이터 전송이 필요한 경우
- 온라인 게임: 실시간 상호작용이 중요한 게임에서 지연 시간을 최소화하기 위해 사용
- 인터넷 전화(VoIP): 음성 데이터의 빠른 전송이 필요한 경우

#### 네트워크 서비스

- DNS(Domain Name System): 도메인 이름 조회에 사용
- DHCP(Dynamic Host Configuration Protocol): IP 주소 할당에 이용
- SMMP(Simple Network Management Protocol): 네트워크 관리에 사용
- NFS(Network File System): 네트워크 파일 시스템에서 활용

#### 기타 응용 분야

- TFTP(Tirvial File Transfer Protocol): 간단한 파일 전송에 사용
- RIP(Routing Information Protocol): 라우팅 정보 교환에 활용

> UDP는 연결 설정 없이 빠른 데이터 전송이 가능하고 오버헤드가 적어, 데이터의 신뢰성보다 속도와 효율성이 중요한 애플리케이션에서 주로 사용됩니다. 특히 실시간 데이터 전송이 필요하거나 일부 데이터 손실이 허용되는 경우에 UDP가 선호됩니다.

## TCP와 UDP의 차이 

| 특성 | TCP | UDP |
|------|-----|-----|
| 연결 방식 | 연결 지향적 (3-way handshake) | 비연결 지향적 |
| 신뢰성 | 높음 (데이터 전달 보장) | 낮음 (데이터 전달 보장 없음) |
| 순서 보장 | 순서대로 전달 | 순서 보장 없음 |
| 속도 | 상대적으로 느림 | 빠름 |
| 오버헤드 | 높음 (20-60 바이트 헤더) | 낮음 (8 바이트 헤더) |
| 흐름 제어 | 있음 | 없음 |
| 혼잡 제어 | 있음 | 없음 |
| 오류 검출 | 있음 | 기본적인 체크섬만 있음 |
| 재전송 | 있음 | 없음 |
| 브로드캐스트 지원 | 지원 안 함 | 지원함 |
| 주요 사용 사례 | 웹 브라우징, 이메일, 파일 전송 | 스트리밍, 온라인 게임, VoIP |

## 마치며

이것으로 TCP와 UDP에 대한 설명을 마무리하겠습니다. 이 두 프로토콜은 네트워크 통신의 핵심이며, 각각의 특징과 사용 사례를 이해하는 것은 효율적인 네트워크 프로그래밍과 시스템 설계에 필수적입니다.