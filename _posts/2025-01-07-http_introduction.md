---
title: "🌐HTTP의 버전차이에 관하여"
date: 2025-01-07 13:32 +0900
categories: [cs]
tags: [http, pipelining]
---

> HTTP는 현대 웹에서 필수적인 중요한 프로토콜입니다. HTTP는 인터넷 상에서 데이터를 주고받는 규칙을 정의하는 프로토콜입니다. HTTP는 웹의 발전과 함께 끊임없이 진화해왔습니다. 본 글에서는 HTTP의 기본 개념부터 시작하여 각 버전별 특징과 발전 과정을 살펴보고, 버전에 따른 사용 현황에 대해 알아보겠습니다.

## 🌐 HTTP란?

HTTP(Hypertext Transfer Protocol)는 프로토콜이라는 말 그대로 클라이언트와 서버가 서로 데이터를 요청/응답하기 위해 사용되는 `통신 규약`을 말합니다. HTTP는 웹 상에서 정보를 주고받는 데 사용하며 다음과 같은 여러 종류의 데이터들을 폭 넓게 전송할 수가 있다. 

![http_evolution.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/http_data.png?raw=true)


> - HTTP의 애플리케이션 프로토콜에서는 전송 프로토콜로 TCP와 UDP 이외에도 QUIC가 있습니다. HTTP의 버전에 따라 사용하는 전송 프로토콜이 다릅니다. 
> - IP는 HTTP와 직접적으로 통신하진 않지만, HTTP 메시지가 네트워크를 통해 전달할 때 출발지에서 목적지까지 전달하는 패킷 라우팅, 네트워크 상의 주소를 식별하는 등 중요한 역활을 합니다.

#### HTTP의 구성요소 

HTTP는 클라이언트와 서버 간의 통신이 가능하다고 했습니다. 이는 HTTP 메시지로 요청과 응답이 가능하게 합니다. HTTP 메시지는 시작 줄(Start Line), 헤더(Headers), 본문(Body)로 이루어져 있으며 예제와 함께 살펴보겠습니다.


**HTTP 요청 예시**를 보며 살펴보겠습니다.
```html 
<!--시작 줄: 메서드, 경로, 버전 -->
POST /api/login HTTP/1.1

<!-- 헤더 -->
Host: www.example.com
Content-Type: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: application/json
Content-Length: 47
Connection: keep-alive

<!-- body -->
{
  "username": "johndoe",
  "password": "secretpass123"
}
```
1. 시작줄 : HTTP 메서드와 경로와 HTTP 버전을 나타내고 있습니다.
    - 메서드 : POST
    - 경로 : /api/login
    - HTTP 버전 : 1.1
2. 헤더 : 요청에 대한 추가 정보를 `Key Value` 형태로 제공합니다.
    - Host : 요청하는 서버의 도메인 이름
    - Content-Type : 메시지 본문의 미디어 타입
    - User-Agent : 클라이언트의 애플리케이션 정보
    - Accept : 클라이언트가 처리 가능한 미디어 타입
3. 본문 : 실제 전송되는 데이터를 나타냄
    - 여기서는 POST 요청으로 JSON 데이터를 실어서 보냈습니다. 


다음으로 **HTTP 응답 예시**입니다.
```html
<!-- 시작 줄 : 버전, 상태 코드, 상태 메시지 -->
HTTP/1.1 200 OK

<!-- 헤더 -->
Date: Tue, 07 Jan 2025 15:30:21 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: application/json; charset=utf-8
Content-Length: 234
Cache-Control: no-cache
X-Powered-By: Express
Access-Control-Allow-Origin: *

<!-- 본문 -->
{
  "status": "success",
  "message": "Login successful",
  "data": {
    "user_id": 12345,
    "username": "johndoe",
    "email": "johndoe@example.com",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```
1. 응답 시작 줄:
    - HTTP 버전
    - 상태 코드: 요청이 성공 여부, 예외 등을 알려주는 코드입니다.
    - 상태 메시지: OK
2. 응답 헤더: 응답에 대한 추가 정보를 `Key Value` 형태로 제공합니다.
    - Date: 응답이 전송된 시간
    - Server: 웹 서버 소프트웨어 정보
    - Content-Type: 응답 본문(body)의 미디어 타입 및 문자 인코딩
    - Content-Length: 응답 본문(body)의 바이트 길이
    - Cache-Control: 캐시 제어
3. 응답 본문: 실제 전송되는 데이터를 나타냅니다.
    - 여기서는 JSON 형식의 데이터입니다.
    - 로그인 성공 상태, 메시지, 사용자 정보 및 인증 토큰을 본문에 포함하여 전송했습니다.

HTTP 메시지의 각 구성요소는 예시와 달리 실제 통신에서는 더 많은 헤더와 복잡한 본문이 포함될 수 있습니다. HTTP 메시지는 이러한 구성요소를 조합하여 클라이언트와 서버 간의 통신을 가능하게 합니다. HTTP 통신에서 각 구성요소는 중요한 역활을 하며, 웹 개발자는 반드시 이를 이해해야 합니다.  

<br>
다음으로 HTTP의 진화과정에 대해 살펴보겠습니다. 

## 🌐 HTTP 진화과정

![http_evolution.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/http_evolution.png?raw=true)

[Web Almance](https://almanac.httparchive.org/en/2024/http)에 따르면 2024년 HTTP 버전별 통계는 다음과 같습니다. 

| HTTP Version | desktop | mobile |
|:--:|:--:|:--:|
|HTTP/1.1|22%|21%|
|HTTP/2|71%|70%|
|HTTP/3|7%|9%|

> HTTP 프로토컬의 버전별 사용량 통계를 살펴보면 웹 기술의 진화 과정과 그 중요성을 명확히 알 수 있습니다. 현재 HTTP/1.1, HTTP/2, HTTP/3가 공존하며 각각의 장단점에 따라 사용되고 있기에 버전에 따른 차이를 알고 있는 것은 중요합니다.

## 🌐 HTTP/0.9 (1991년)

HTTP/0.9는 WWW(World Wide Web)의 초기 버전으로, 1991년에 팀 버너스 리(Tim Berners-Lee)가 학술 정보 교환을 위해 개발되었습니다. 당시의 HTTP는 극도로 단순한 프로토콜이며 특징은 다음과 같습니다. 

- 요청은 단일 라인으로, GET 메서드만 지원했습니다.
- HTTP헤더가 없었으며, HTML 파일만 전송 가능했습니다.
- 상태 코드가 없었기 때문에 특정 html 파일을 오류에 대한 설명과 함께 보냈다.
- 각 요청마다 새로운 TCP 연결을 생성하고 응답 후 즉시 종료했습니다.

## 🌐 HTTP/1.0 (1996년)

인터넷이 빠르게 진화하며 HTTP/0.9를 사용해서 HTML 문서는 물론 다양한 컨텐츠가 필요해졌습니다. 이에 HTTP-WG는 HTTP/1.0의 문서 [`RFC 1945`](https://datatracker.ietf.org/doc/html/rfc1945)를 발표하게 된다. 이때부터 앞서 설명했던 HTTP 구조의 예시와 같은 형태로 구성되어 있습니다. HTTP/1.0 특징은 다음과 같습니다.

- HTTP 헤더를 도입함으로써 메타데이터 전송이 가능해졌습니다.
- 상태 코드를 도입함으로써 서버 응답 상태를 명확히 알 수 있습니다.
- 다양한 메서드로 클라이언트와 서버 간의 더 풍부한 상호작용이 가능해졌습니다.

이로 인해 HTTP/1.0에서 다양한 타입의 정보를 전송할 수 있게 되었고, 헤더와 상태 코드로 인해 클라이언트와 서버 간의 통신이 원활해졌습니다. 하지만 HTTP/1.0은 각 요청마다 계속 TCP 연결을 열고, 응답하면 닫았어야 했으며, TCP가 연결될 때 슬로우 스타트가 발생하여 속도면에서 문제가 많았습니다. 인터넷이 발달함에 있어 HTTP/1.0으로는 웹에서 효율적으로 작동하기 어렵다는 것이 HTTP/1.1이 개발된 이유 중 하나입니다.

## 🌐 HTTP/1.1 (1997년)

위에서 HTTP/1.1이 개발된 이유에 대해 간략히 살펴보았습니다. HTTP/1.1은 HTTP/1.0의 단점을 해결하기 위해 HTTP/1.0이 출시된 지 6개월 만에 릴리즈되었습니다. HTTP/1.1의 특징은 다음과 같습니다.

1. 지속적 연결(Persistent Connections):
    - HTTP/1.1은 하나의 TCP 연결을 통해 `여러 요청, 응답`을 처리할 수 있게 되었습니다. 이는 연결 설정에 따른 오버헤드를 줄여 성능을 크게 향상시켰습니다.
2. 파이프라이닝(PipeLining):
    - 클라이언트가 이전 요청에 대한 응답을 기다리지 않고 여러 요청을 연속적으로 보낼 수 있게 되어 지연 시간을 줄였습니다.
3. 호스트 헤더(Host Header):
    - 필수 호스트 헤더의 도입으로 하나의 IP 주소에서 여러 도메인을 호스팅할 수 있게 되어 IP 주소 부족 문제를 완화하여 리소스 효율성을 증가시켰습니다.
4. 다이제스트 인증과 프록시 인증 등 다양한 인증 방식을 도입하여 보안 및 인증을 개선시켰습니다.
5. 이외에도 캐시 제어 헤더, 조건부 요청 헤더, OPTIONS 메서드 등이 개선되거나 추가되었습니다.

#### 💬지속적 연결과 파이프라이닝

![http_connection.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/http_connection.png?raw=true)

기존의 HTTP/1.0은 단기 연결로 연결을 보내고 응답을 받으면 연결을 닫았습니다. 이 과정에서 많은 지연이 발생합니다. 그래서 HTTP/1.1에서는 한 번 연결하면 이를 재사용하는 `지속적 연결(Persistent Connection)`을 사용하여 지연을 개선하였습니다. 연결을 유지하는 시간이 길어질 수록 서버에 부하가 생기기 때문에 연결을 유지하는 시간을 `Keep-Alive`로 제한합니다.  
<br>

또한, 위의 마지막 그림의 파이프라이닝은 여러 요청을 보냈을 때, 각 응답을 기다리지 않고 여러 요청을 연속적으로 보낼 수 있게 해주는 기술입니다. 그림에선 네트워크 지연이 점점 감소하여 성능이 향상되어 보이지만 파이프라이닝은 실제 구현과 사용에 있어 여러 제약이 있어 널리 채택되지 못했습니다. 

## 🌐 HTTP/2.0 (2015년)

웹 페이지가 더 발달함에 따라 훨씬 더 많은 HTTP 요청으로 데이터가 전송되었고, HTTP/1.1 연결에서는 복잡성과 오버헤드가 많이 발생하였습니다. 이를 해결하기 위해 Google은 SPDY를 개발하였습니다. SPDY는 응답성 증가를 정의하고, 중복 데이터 전송 문제를 해결하여 HTTP/2.0의 기반이 됩니다. 

> SPDY는 웹 성능 향상을 위해 개발한 비표준 개방형 네트워크 프로토콜입니다. 텍스트가 아닌 바이너리 프로토콜로 파싱 속도를 높이고, 오류 발생 가능성을 줄였습니다.
> 구글에서 SPDY를 적용했을 때 HTTP/1.1보다 로딩 속도가 23%~43% 빨라졌다고 합니다.

HTTP/2.0의 특징은 다음과 같습니다.

- 이진(binary) 프로토콜:
    - HTTP/1.1은 텍스트 기반 프로토콜로 사람이 읽기는 좋지만, 불필요하게 데이터가 커지는 문제가 있었습니다. HTTP/2.0은 텍스트 대신 이진 형식으로 데이터 전송을 하여 파싱 속도와 리소스 효율을 향상시키고, 오류 발생 가능성을 감소시켰습니다.
- 응답 다중화(Multiplexing):
    - 하나의 TCP 연결로 여러 요청과 응답을 동시에 처리하여 네트워크 지연 시간을 감소시키고, 페이지 로딩 속도를 향상시켰습니다.
    - 특히, HTTP/1.1의 파이프라이닝의 HOLB(Head-of-Line-Blocking) 문제를 해결했습니다.
- 헤더 압축(Header Compression):
    - HPACK이라고 부르는 헤더 압축 기술은 중복되는 부분은 전송하지 않기 때문에 HTTP/1.1에서 동일한 헤더를 보내는 것에서 발생하는 오버헤드를 최소화할 수 있습니다.

이외에도 서버 푸시, 스트림 우선순위가 있습니다. HTTP/2.0의 특징은 웹 페이지 로딩 속도를 크게 향상시키고, 네트워크 리소스 사용을 최적화하며, 전반적인 웹 성능을 개선했습니다.

> 실제 웹 페이지 로딩 시간을 약 4~15%정도 개선했다고 하며, 특히 많은 작은 객체 또는 큰 객체를 요청할 때 더욱 뛰어난 성능 향상이 있었습니다.
> - 많은 작은 객체 : 15% 이상 개선
> - 많은 큰 객체 : 약 33% 개선



## 🌐 HTTP/3.0 (2022년)

HTTP/3.0은 HTTP/2.0 뿐만 아니라 그동안의 HTTP 프로토콜이 TCP로 동작하기 때문에 발생하는 문제를 해결하기 위함입니다. 

TCP의 단점에 대해 간단히 말하자면, 
1. TCP는 3-way handshake가 필요하며, 왕복하는데 더 많은 지연 시간이 소요됩니다.
2. TCP는 신뢰성을 목적으로 하는데, 전송 과정에서 데이터 손실이 발생하면 재전송을 수행합니다. TCP는 순서대로 패킷을 전송하는데 재전송하는 과정에서 병목현상이 일어나 HOLB 문제가 발생합니다. 

위와 같은 TCP의 단점을을 해결하기 위해 QUIC 방식인 HTTP/3.0이 개발되었습니다.

QUIC(Quick UDP Internet Connections)은 구글이 개발한 인터넷 전송 프로토콜입니다. UDP 기반의 프로토콜로, TCP와 UDP의 장점을 결합했습니다. QUIC 프로토콜을 사용한 HTTP/3.0의 특징은 다음과 같습니다. 

1. QUIC 프로토콜을 사용하여 연결 설정 시간을 단축합니다.
2. 독립적인 스트림 처리로 멀티플렉싱을 향상시켜 HOLB 문제를 해결합니다.
3. 패킷 손실 처리가 개선되었습니다. 
> 패킷 손실이 15% 정도일 때 HTTP/2.0보다 55% 더 나은 성능을 보인다고 합니다. 
4. 보안 강화: TLS 1.3을 사용하여 더 강력한 암호화를 제공합니다. 
5. 저지연 통신: O-RTT 재개를 통해 이전 방문 서버와 즉시 재연결이 가능합니다.
6. HTTP/3.0은 TLS 1.3을 기본적으로 내장하고 있어 향상된 보안을 가집니다.

특징만 보면 매력적인 기술이나 다음과 같은 단점 또한 존재합니다. 

1. QUIC 프로토콜의 도입으로 구현과 관리가 더 복잡해질 수 있습니다. 
2. 모든 서버와 클라이언트가 HTTP/3.0을 지원하지 않아 호환성 문제가 발생할 수 있습니다.
3. 일부 네트워크 환경에서 UDP 트래픽이 차단되거나 제한될 수 있습니다. 

> HTTP/3.0은 전반적으로 웹 성능을 크게 향상시키지만, 새로운 기술 도입에 따른 호환성 문제와 복잡성이 존재합니다.

## 마치며 

HTTP의 초기 버전의 HTTP/0.9부터 HTTP/3.0까지 알아보았습니다. 각 버전은 이전 버전의 한계를 극복하고 웹의 요구사항을 충족시키기 위해 진화해왔습니다. 주요 발전 사항을 간략히 정리해보면 다음과 같습니다.

- HTTP/1.1: 지속적 연결. 파이프라이닝 등을 도입하여 성능을 크게 개선했습니다. 
- HTTP/2.0: 멀티플렉싱, 헤더 압축 등을 통해 웹 페이지 로딩 속도를 대폭 향상시켰습니다.
- HTTP/3.0: QUIC 프로토콜을 도입하여 연결 설정 시간 단축, HOLB 문제 해결 등 더욱 빠르고 안정적인 통신을 가능하게 했습니다. 

저는 HTTP의 발전 과정을 알아보면서, HTTP 각 버전의 특징과 장단점을 알고 적절히 활용하는 것이 개발자에 있어서 필수적이라고 생각합니다. 자신의 프로젝트 규모와 전송하는 데이터 타입에 따라 HTTP를 선택한다면 더 효율적이고 안정적으로 웹 및 애플리케이션을 구축할 수 있을 것이라고 생각합니다.