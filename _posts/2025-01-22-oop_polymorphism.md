---
title: "[Java] OOP Part6. 다형성 알아보기"
date: 2025-01-22 09:08 +0900
categories: [Java]
tags: [Java, OOP, Polymorphism]
---

## 다형성(Polymorphism)이란?

다형성이란 "poly"(많은)와 "morphs"(형태)의 그리스어 조합으로, "여러 가지 형태를 가진" 또는 "다형성"을 의미합니다. 이는 하나의 개체가 여러 가지 다른 형태나 구조로 존재할 수 있는 능력을 나타냅니다. 

객체 지향 프로그래밍에서는 하나의 객체가 여러 가지 형태를 가지는 것을 의미합니다. 즉, 같은 타입의 참조 변수를 통해 여러 타입의 객체를 참조할 수 있는 특성을 말합니다. 

자바에서는 가장 일반적으로 사용되는 **부모 클래스 참조를 사용하여 자식 클래스 객체를 참조하는 상속** 외에도 **오버라이딩, 오버로딩, 인터페이스, 추상 클래스, 업캐스팅**이 있습니다. 이러한 방법들을 통해 객체가 여러 가지 형태를 가질 수 있도록 하여 다형성을 구현할 수 있습니다. 

> 제너릭을 사용하여 다양한 타입에 대해 동일한 코드를 재사용하는 방법도 있지만 여기서는 다루지 않겠습니다.

## 다형성이 필요한 이유

실생활에서 다형성을 이해하기 좋은 예시로 TV 리모컨이 있습니다. 

여러 브랜드의 TV가 있지만, 대부분의 리모컨은 비슷한 버튼 구조를 가지고 있습니다. 전원 버튼, 채널 변경 버튼, 음량 조절 버튼 등이 공통적으로 존재합니다. 이는 자바에서 추상 클래스나, 인터페이스의 역활과 유사합니다. 이를 자바 코드로 표현하면 다음과 같습니다.

```java
interface TV {
    void turnOn();
    void turnOff();
    void changeChannel(int channel);
    void adjustVolume(int volume);
}
```
또한, 각 TV 브랜드는 이 인터페이스를 구현하지만, 내부 동작 방식은 다를 수 있습니다. 

```java
class SamsungTV implements TV {
    @Override
    public void turnOn(){
        System.out.println("삼성 TV 전원 켜기");
        // 삼성 TV만의 고유한 전원 켜기 로직
    }
}

class LGTV implements TV {
    @Override
    public void turnOn(){
        System.out.println("LG TV 전원 켜기");
        // LG TV만의 고유한 전원 켜기 로직
    }
}
```

위와 같은 예시들의 핵심은 **다양한 구현을 동일한 인터페이스로 다룰 수 있다는 점**입니다. 

```java
TV remoteControl1 = new SamsungTV();
TV remoteControl2 = new LGTV();

remoteControl1.turnOn(); // 삼성 TV 전원 켜기 
remoteControl2.turnOn(); // LG TV 전원 켜기
```

여기서 'remoteControl1'과 'remoteControl2'는 모두 'TV' 타입이지만, 실제로는 각각 다른 브랜드의 TV 객체를 참조하고 있습니다. 'turnOn()' 메서드를 호출할 때, 각 객체의 실제 타입에 따라 다른 동작이 수행됩니다. 위의 예시에서 'TV'는 리모컨을 의미하고, 여러 브랜드의 TV를 하나의 리모컨으로 제어할 수 있지만 내부 동작 방식은 모릅니다. 즉, 자바에서 'TV'라는 곳에서 **동일한 메서드 호출**이 있지만 객체의 실제 타입에 따라 다르게 동작할 수 있는 것이 다형성의 핵심입니다.

> TV라는 상위 클래스에 하위 클래스 객체를 넣는 방법(`TV tv = new SamsungTV()`)을 `업캐스팅`이라고 합니다. [이 글](https://euihyunee.github.io/posts/oop_inheritance/#%EC%97%85%EC%BA%90%EC%8A%A4%ED%8C%85upcasting)에서 자세히 다루니 참고하길 바랍니다.

✅다형성을 통한 이점은 다음과 같습니다.

1. **코드의 재사용성**: 하나의 리모컨 인터페이스로 여러 브랜드의 TV를 제어할 수 있듯이, 하나의 인터페이스나 추상 클래스로 여러 구현체를 다룰 수 있습니다.
2. **유연성과 확장성**: 새로운 TV 브랜드가 나오더라도 기존 리모컨을 바꾸지 않고 사용할 수 있듯이, 새로운 클래스를 추가할 때 기존 코드의 수정을 최소화할 수 있습니다.
3. **유지보수의 용이성**: TV의 내부 동작이 변경되어도 리모컨 사용법은 그대로인 것처럼, 클래스의 내부 구현이 변경되어도 그 클래스를 사용하는 코드는 변경할 필요가 없습니다.
4. **복잡성 감소**: 사용자가 각 TV 브랜드별로 다른 리모컨 사용법을 배울 필요가 없듯이, 프로그래머는 각 구현체의 세부사항을 알 필요 없이 공통 인터페이스만 알면 됩니다.

자바의 다형성은 실생활의 리모컨처럼, 다양한 객체를 일관되게 다룰 수 있게 해줍니다. 이를 통해 코드의 재사용성, 유연성, 유지보수성을 높이고, 복잡성을 줄일 수 있습니다. 결과적으로 더 효율적이고 확장 가능한 프로그램을 만들 수 있게 되는 것입니다. 아래에서 다형성을 구현하는 방법을 알아보겠습니다.

## 자료형 다형성 

위의 예시에서 `TV tv = new LGTV()`로 선언해서 사용해보았습니다. 이는 'TV'라는 인터페이스 또는 상위 클래스에서 다양한 객체를 넣을 수 있음을 의미합니다. 이는 Collection 프레임워크로 바꿀 수 있다는 겁니다.

```java
List<TV> tvs = new  ArrayList<>();

// TV 객체 추가
tvs.add(new SamsungTV());
tvs.add(new LGTV());

// 모든 TV 켜기
for(Tv tv : tvs) {
    tv.turnOn();
}

// 첫 번째 TV의 채널 변경
if(!tvs.isEmpty()) {
    tvs.get(0).turnOn();
}

// 마지막 TV 끄기
if(!tvs.isEmpty()) {
    tvs.get(tvs.size()-1).turnOff();
}
// 특정 TV 제거
if(tvs.size() > 1){
    tvs.remove(1);
}
```

위 예제에서는 List를 통하여 객체들을 효율적으로 관리하는 방법들을 보여줍니다.

이처럼 컬렉션 프레임워크인 List, Set, Map 등을 사용해 다양한 객체를 동일한 방식으로 다룰 수 있습니다. 이를 통해 개발자는 특정 구현에 종속되지 않고 유연한 코드를 작성할 수 있습니다.

## 메서드 다형성 

메서드 다형성은 **동일한 메서드 이름으로 다양한 동작을 구현할 수 있는 능력**을 의미합니다. 메서드 다형성을 구현하는 주요 방법은 대표적으로 `오버로딩(Overloading)`과 `오버라이딩(Overriding)`이 있습니다.

### 오버로딩(Overloading)

오버로딩은 같은 이름의 메서드를 매개변수의 타입, 개수, 순서 등을 다르게 하여 여러 개 정의하는 것입니다. 이를 통해 동일한 기능을 하는 메서드를 다양한 매개변수로 호출할 수 있습니다.

```java
class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    public String add(String a, String b) {
        return a + b;
    }
}
```

오버로딩은 동일한 이름을 가지며 매개변수 개수, 타입, 순서 중 하나 이상이 달라야 합니다. 이처럼 오버로딩은 같은 클래스 내에서 동일한 이름의 메서드를 여러 개 정의하여 다형성을 이룹니다. 

오버로딩은 단순히 클래스에서 메서드의 다형성을 구현하기도 하지만 하위 클래스에서 오버라이딩된 메서드 또한 구현하는 것이 가능합니다. 다만, 업캐스팅된 객체는 상위 클래스의 메서드만 사용할 수 있으므로 객체를 다운캐스팅하여 사용해야 하는 주의점이 있습니다.

### 오버라이딩(Overriding)

오버라이딩은 부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의하는 것입니다. 이를 통해 같은 메서드 이름으로 다른 동작을 구현할 수 있습니다. 오버라이딩은 **상속, 인터페이스, 추상 클래스**에서 사용할 수 있습니다. 

```java
interface TV {
    void turnOn();
}
class SamsungTV implements TV {
    @Override
    public void turnOn(){
        System.out.println("삼성 TV 전원 켜기");
        // 삼성 TV만의 고유한 전원 켜기 로직
    }
}
class LGTV implements TV {
    @Override
    public void turnOn(){
        System.out.println("LG TV 전원 켜기");
        // LG TV만의 고유한 전원 켜기 로직
    }
}
// Main
TV tv1 = new SamsungTV();
TV tv2 = new LGTV();

tv1.turnOn(); // 삼성 TV 전원 켜기
tv1.turnOn(); // LG TV 전원 켜기
```

위 예시처럼 오버라이딩은 기본적으로 상위 타입에서 정의된 메서드를 하위 타입에서 재정의하는 개념입니다. 오버라이딩을 활용해서 'TV'라는 같은 타입에서 같은 메서드를 호출하지만 실제 객체에 따라서 메서드를 호출합니다. 


## 매개변수 다형성 

매개변수 다형성은 하나의 메서드로 여러 타입의 객체를 처리할 수 있습니다. 이렇게 언급하면 오버로딩을 떠올리겠지만 실제로는 다른 개념입니다. 매개변수 다형성은 하나의 메서드가 여러 타입의 인자를 처리할 수 있는 개념인 반면, 오버로딩은 같은 이름의 함수나 메서드를 여러 개 정의하여 다양한 매개변수 조합을 처리하는 기법입니다. 

상위 클래스 타입의 매개변수를 사용하여 자식 클래스의 객체를 받을 수 있는 방법이 있습니다.

```java 
void buy(TV tv){
    price = tv.price;
    bonusPoint = tv.bonusPoint;
}
```

위의 예제는 'TV' 타입의 매개변수를 받지만, 'TV'의 모든 하위 클래스 객체도 인자로 전달될 수 있습니다.

이외에도 매개변수 다형성에는 제네릭 프로그래밍이 있습니다.

```java
public class Box<T>{
    private T content;

    public void setContent(T content){
        this.content = content;
    }
    public T getContent(){
        return content;
    }
}
```

이 예시에서 'Box' 클래스는 어떤 타입의 객체도 저장할 수 있습니다. 이처럼 매개변수 다형성을 이룬다는 것은 하나의 메서드로 여러 타입의 객체를 처리할 수 있어 코드 중복을 줄일 수 있습니다.
이외에도 메서드 레벨 제너릭, 타입 매개변수 제약, 와일드카드를 사용하여 매개변수의 다형성을 이룰 수 있습니다.

## 마치며 

오늘은 객체 지향 프로그램밍의 강력한 도구인 다형성에 대해 알아보았습니다. 다형성은 복잡한 시스템을 더 간단하고 효율적으로 설계할 수 있게 해주는 설계 기법입니다. 무저건적으로 사용해야 하는 만능 해결책이 아니라 각 상황에 맞게 적절히 사용해야 합니다. 개발자는 다형성의 개념과 적용 방법을 깊이 이해하여 유지보수가 용이하고, 확장 가능하며, 효율적인 소프트웨어를 설계할 수 있어야 합니다. 다형성의 이해는 단순한 기술적 지식을 넘어, 더 나은 소프트웨어 아키텍처를 설계하는 능력을 키우는 데 필수적입니다.