---
title: "📋 데이터베이스 설계의 핵심: 정규화와 반정규화"
date: 2025-02-11 10:30 +0900
categories: [Database]
tags: [Normaliztion, DeNormalization, RDMBS]
---

> 데이터베이스 설계에서 효율적이고 일관된 데이터 관리를 위한 과정으로 정규화와 반정규화가 있습니다. 정규화는 데이터의 중복을 최소화하고 데이터 무결성을 보장하는 과정인 반면, 반정규화는 성능 향상을 위해 의도적으로 중복을 허용하는 기법입니다. 이 글에서는 정규화와 반정규화의 개념, 목적, 그리고 장단점에 대해 알아보겠습니다.

## 정규화란?

정규화(Normalization)는 관계형 데이터베이스 설계에서 중요한 개념으로, 데이터의 중복을 최소화하고 데이터의 일관성과 무결성을 유지하기 위한 프로세스입니다.

### 정규화의 목적

1. **데이터 중복 제거**: 테이블 간 중복되는 데이터를 허용하지 않음으로써 저장 공간을 절약합니다.
2. **데이터 무결성 유지**: 중복을 제거함으로써 데이터의 일관성을 보장합니다.
3. **이상현상 방지**: 삽입, 갱신, 삭제 시 발생할 수 있는 이상 현상을 예방합니다.
4. **데이터 구조 최적화**: 데이터베이스의 구조를 더 효율적으로 만듭니다.

### ⚠️이상현상이란?

이상현상(Anomaly)은 데이터베이스 설계가 잘못되어 발생하는 데이터의 불일치 문제를 말합니다. 주로 데이터의 중복으로 인해 발생하며, 데이터의 삽입, 삭제, 수정 시 논리정 오류를 일으킵니다.

1. **삽입 이상**: 새로운 데이터를 삽입할 때 의도하지 않은 데이터까지 함께 삽입해야 하는 문제
2. **삭제 이상**: 특정 데이터를 삭제할 때 의도치 않게 다른 중요한 정보까지 함께 삭제되는 현상
3. **갱신 이상**: 데이터 수정 시 일부 튜플만 변경되어 데이터의 불일치가 발생하는 현상

> 삽입 이상: ex) 새로운 학생 정보를 추가할 때 해당 학생이 수강하는 강의 정보가 없다면 `NULL` 값을 입력해야 하는 상황 발생
> 삭제 이상: ex) 특정 강의를 삭제하면 해당 강의를 수강하는 학생의 정보까지 모두 삭제되는 경우
> 갱신 이상: ex) 학생의 전화번호를 변경할 때 여러 곳에 중복 저장된 정보 중 일부만 수정되어 불일치가 발생

✅ 이상현상을 해결하기 위해 데이터베이스 정규화 과정을 거쳐 데이터의 중복을 최소화하고 데이터 구조를 개선합니다.

## 정규화 단계 

정규화는 여러 단계로 진행되며, 각 단계는 이전 단계의 조건을 포함합니다. 3차 정규화 정도만 알

### 제 1정규형(1NF)

![first_normalization.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/first_normalization.png?raw=true)

초기 테이블은 '강의명' 속성이 다중값을 가지고 있기 때문에 '강의명' 속성을 

- 모든 속성의 도메인이 원자값만을 포함해야 합니다.
- 반복되는 그룹이 없어야 합니다.

### 제 2정규형(2NF)

![second_normalization.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/second_normalization.png?raw=true)


- 1NF를 만족하며, 부분 함수적 종속을 제거합니다.
- 모든 비주요 속성이 기본키에 완전 함수적 종속이어야 합니다.

### 제 3정규형(3NF)

![third_normalization.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/third_normalization.png?raw=true)

- 2NF를 만족하며, 이행적 함수 종속을 제거합니다.
> 이행적 함수 종속: X->Y, Y->Z일 때, X->Z가 성립
- 기본키가 아닌 모든 속성이 기본키에 직접 종속되어야 합니다.

이렇게 테이블을 분리함으로써 얻는 이점은 다음과 같습니다.

1. 이행적 함수 종속성이 제거되었습니다. 강의명에서 직접 부서로 연결되는 종속성이 없어졌습니다.
2. 데이터 중복이 줄어들었습니다. 강사와 부서는 한 번만 저장됩니다.
3. 데이터 갱신이 용이해졌습니다. 예를 들어, 강사의 소속 학과가 변경될 경우 강사 테이블만 수정하면 됩니다.
4. 각 테이블은 하나의 주제에 대한 정보만을 다루게 되어 데이터의 일관성과 무결성이 향상되었습니다.

### ⚠️이행적 함수 종속성을 제거하는 이유 
위의 예시에서 학생의 수강 과목이 변경될 때 관련된 모든 데이터를 일관되게 업데이트 하기 어려울 수 있습니다. 이행적 함수 종속성은 데이터 불일치, 갱신 이상, 데이터 중복 등을 발생시킬 수 있습니다. 따라서 이행적 함수 종속성을 제거하여 검색 효율성, 데이터 무결성, 유지보수성을 향상시켜 데이터베이스의 구조를 개선하고 데이터 관리의 효율성을 높일 수 있습니다.

### 보이스-코드 정규형(BCNF)

- 3NF를 강화한 버전으로, 모든 결정자가 후보키여야 합니다.

위에서 제 3정규화를 마치고 난 테이블을 보면 모든 속성이 별도의 후보키가 될 수 있습니다. 이 예시는 BCNF를 이미 만족하여 모든 결정자가 후보키가 됩니다. 만일 제 3정규형에서 모든 결정자가 후보키가 아닐 경우 테이블 분리를 통해 BCNF 정규형을 만듭니다.

> 정규화를 통해 데이터베이스 설계를 개선할 수 있습니다. 정규화는 데이터의 논리적 구조를 개선하지만, 때로는 데이터 중복을 증가시킬 수 있습니다. 이에 성능 향상을 위해 의도적으로 정규화를 거스르는 반정규화 과정을 수행하기도 합니다. 아래에서 반정규화에 대해 알아보겠습니다.

## 반정규화란?

반정규화는 데이터베이스의 성능 향상을 위해 정규화된 데이터 모델에서 의도적으로 중복을 허용하는 프로세스입니다. 즉, 기본적으로 정규화된 데이터 모델에서 특정 부분의 개발과 운영을 단순화하여 성능을 향상시킬 수 있는 기법입니다. 하지만 데이터의 일관성과 무결성을 일부 무시하면서 성능을 개선하는 만큼 신중한 검토와 결정을 통해 적절한 수준의 반정규화를 수행해야 합니다.

## 반정규화 절차

![semi_normalization.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/semi_normalization.png?raw=true)

반정규화를 수행할 때는 데이터의 일관성과 무결성을 고려해야 하며, 과도한 정규화는 오히려 성능을 저하시킬 수 있으므로 신중하게 접근해야 합니다.

## 반정규화 기법

주요 반정규화 기법은 다음과 같습니다.

### 테이블 반정규화

![normalization_table.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/normalization_table.png?raw=true)

- **테이블 병합**: 자주 조인되는 테이블을 하나로 통합하여 조인 연산을 줄입니다.
- **테이블 분할**:
    - 수직 분할: 특정 속성들만 자주 접근되는 경우, 해당 칼럼들을 별도 테이블로 분리합니다.
    - 수평 분할: 데이터 값에 따라 행을 나누어 별로의 테이블로 관리합니다.
- **테이블 추가**: 요약 정보나 하위 정보를 별도의 테이블로 생성합니다.

### 속성 반정규화

- **중복 칼럼 추가**: 조인을 줄이기 위해 다른 테이블의 칼럼을 중복하여 추가합니다.
- **파생 칼럼 추가**: 계산된 값을 미리 저장하여 조회 시 연산을 줄입니다.
- **이력 테이블 칼럼 추가**: 대량의 이력 데이터 처리를 위해 최근 값 여부, 시작일, 종료일 등의 칼럼을 추가합니다.
- **PK에 의한 칼럼 추가**: 조인 성능 향상을 위해 인조 식별자를 추가합니다.

### 관계 반정규화

- **중복 관계 추가**: 데이터 처리의 다양한 경로를 제공하기 위해 추가적인 관계를 설정합니다.

## 반정규화의 대안 

반정규화는 데이터베이스의 성능을 향상시키기 위해 사용되지만, 데이터 중복 및 무결성 저하 등의 단점이 있습니다. 그렇기에 이를 보완하거나 대체할 수 있는 대안들을 먼저 사용하는 게 일반적인 접근 방식입니다. 각 대안은 특정 상황에 적합하게 사용할 수 있습니다.

### 클러스터링(Clustering)

데이터를 물리적으로 정렬하여 저장하는 방식으로 동일한 범위나 관련 데이터를 인접 블록에 저장합니다.

- 장점: 조회 성능이 향상되며, 인접 데이터를 연속적으로 읽을 수 있어 I/O 비용이 감소합니다.
- 적용 사례: 특정 범위의 데이터를 자주 조회하는 경우

### 인덱스 튜닝(Index Tuning)

적절한 인덱스를 생성하거나 기존 인덱스를 최적화하여 데이터 검색 속도를 향상시킵니다.

- 장점: 데이터 중복 없이 조회 성능을 개선할 수 있습니다.
- 적용 사례: 특정 열에 대해 검색이 빈번히 발생하는 경우

### 뷰(View) 생성

자주 사용하는 복잡한 쿼리를 뷰로 정의하여 재사용합니다.

- 장점: 원본 데이터를 변경하지 않고도 복잡한 조회를 단순화할 수 있습니다.
- 적용 사례: 동일한 쿼리가 반복적으로 사용되는 경우

### 파티셔닝(Partitioning)

테이블을 논리적으로 분할하여 데이터를 관리합니다. 수평 분할(행 기준)과 수직 분할(열 기준)이 포함됩니다.

- 장점: 대량 데이터 처리 성능 향상 및 관리 용이성 제공
- 적용 사례: 특정 조건에 따라 데이터를 자주 조회하거나 갱신하는 경우 

### 애플리케이션 로직 변경

데이터베이스 설계 대신 애플리케이션 레벨에서 성능 최적화를 수행합니다.

- 장점: 데이터베이스 구조를 변경하지 않고도 성능 문제를 해결 가능
- 적용 사례: 특정 비즈니스 로직에 따라 데이터 접근 방식이 최적화될 수 있을 때

### 캐싱(Caching)

자주 조회되는 데이터를 메모리에 저장하여 빠르게 액세스 합니다.

- 장점: 데이터베이스 부하를 줄이고 응답 속도를 크게 향상시킵니다.
- 적용 사례: 동일한 데이터가 반복적으로 요청되는 경우

### 샤딩(Sharding)

테이블을 여러 물리적 서버에 분산 저장하여 부하를 분산합니다.

- 장점: 대규모 트래픽 처리 및 확장성 제공
- 적용 사례: 대량의 데이터를 처리해야 하는 분산 시스템

## 마치며 

정규화와 반정규화는 데이터베이스 설계에서 중요한 개념으로, 각각의 장단점을 고려하여 적절히 활용해야 합니다. 데이터의 일관성과 무결성이 중요한 경우 정규화를 지키는 것이 좋습니다. 성능을 위해서 반정규화를 적용하기 전에 인덱싱, 뷰, 클러스터링 등의 대안을 검토하고 필요한 경우에만 제한적으로 반정규화를 적용하는 것이 일반적인 접근 방식입니다. 

무엇보다 반정규화는 데이터베이스 설계를 하기위한 기술 중 하나입니다. 고려하는 기술이지 절대적인 사용할 필요는 없습니다. 데이터베이스 설계에는 비즈니스 요구사항, 데이터의 특성, 그리고 시스템의 전반적인 아키텍처를 고려한 전략적 결정이 필요합니다. 정규화와 반정규화에 대해 잘 학습하고 데이터베이스 설계에 적절히 사용하길 바랍니다.