---
title: "📋 트랜잭션과 ACID 원칙"
date: 2025-02-07 09:10 +0900
categories: [Database]
tags: [Transaction, ACID]
---

## 트랜잭션(Transaction)이란?

트랜잭션(Transaction)은 데이터베이스의 상태를 변화시키기 위해 수행되는 작업의 최소 단위를 의미합니다. 이는 데이터베이스에서 수행되는 여러 SQL 명령어들을 하나의 논리적 작업으로 묶어 처리하는 것을 말합니다.

이는 여러 관련 작업의 결과를 묶어서 처리한다고 표현할 수 있습니다. 

예를 들어, 계좌 이체 과정에서 출금과 입금 작업은 하나의 트랜잭션으로 처리해야 합니다. 만일, 출금과 입금 작업을 분리할 시 한 계좌에서 돈이 빠져나갔지만 다른 계좌에 입금되지 않는 등의 불일치 상황을 방지할 수 있습니다.

![transaction_example.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/transaction_example.png?raw=true)

언뜻 보기에는 트랜잭션을 써도 A가 출금을 하고 B계좌에 입금되기 전에 요청을 보내면 똑같이 B계좌는 입금이 안 된 상태가 조회된다. 구체적으로 살펴보면 작업 분리에서 A가 출금을 했을 때 B가 100원을 포함한 모든 돈을 다른 곳에 사용한다면 B계좌에 입금될 때 B는 -100원이 된다. 반면, 트랜잭션을 사용하면 이 작업이 내부에서는 순서대로 처리되지만, 외부에서 보기엔 출금과 입금이 동시에 된 것으로 보이게 됩니다. 

또한, A의 입금은 성공했지만, B 계좌의 출금이 실패했을 경우 작업을 분리한다면 결과가 이상해진다. 이때 트랜잭션을 사용하면 중간에 오류가 났을 경우 작업을 원상태로 복구시킨다. 트랜잭션은 처리 과정이 모두 성공하는 것 외에는 결과를 반영하지 않기 때문에 데이터의 안정성을 확보할 수 있습니다.

이처럼 `트랜잭션`은 여러 관련 ***작업의 결과를 일괄적으로 적용하거나 취소***함으로써 데이터베이스의 <span style="color:red">**안정성과 신뢰성**</span>을 보장하는 중요한 메커니즘입니다.

## 트랜잭션의 성질(ACID)

위의 예시와 같이 트랜잭션에는 데이터베이스의 안전성을 보장하기 위한 네 가지 핵심 특성이 있습니다. 네 가지의 특성의 앞 글자로 구성된 `ACID`로 불립니다.

### 원자성(Atomicity)

트랜잭션의 모든 작업이 완전히 수행되거나 전혀 수행되지 않아야 하는 특성입니다. 흔히들 "모 아니면 도"라고 설명하기도 하는 이 원칙은 다음과 같은 특징이 있습니다.

1. 트랜잭션 내의 모든 작업은 하나의 단위로 취급됩니다.
2. 트랜잭션에 포함된 모든 작업이 성공적으로 완료되면 전체가 커밋됩니다.
3. 만에 하나라도 실패하면 전체 트랜잭션이 롤백되어 모든 변경 사항이 취소됩니다.

예시로 출금과 입금이 모두 성공해야 트랜잭션이 완료되며, 둘 중 하나라도 실패하면 전체 거래가 취소됩니다.

### 일관성(Consistency)

데이터베이스의 상태가 트랜잭션 전후로 일관된 상태를 유지해야 함을 의미합니다. 쉽게 말해, 데이터베이스의 규칙을 지키면서 데이터가 올바르게 저장되고 유지되는 것입니다.

일관성을 이해하기 위해서는 데이터베이스의 규칙과 제약조건을 알아야 합니다. 여기서는 쉽게 예시를 들어보겠습니다.

1. 은행 계좌 규칙: 모든 계좌의 잔액은 0원 이상이어야 합니다. 만약 출금으로 인해 잔액이 마이너스가 된다면, 이는 일관성을 위반하는 것입니다.
2. 온라인 쇼핑몰: 재고가 0인 상품은 판매할 수 없습니다. 재고가 없는데 주문이 들어오면, 시스템은 이를 막아야 합니다.

트랜잭션의 일관성은 마치 유효성 검사와 밀접한 관련이 있어 보입니다. 데이터가 입력되거나 수정될 때 미리 정의된 규칙에 따라 데이터의 정확성과 적절성을 확인하는 과정을 거쳐 데이터의 품질을 보장하는 공통점이 있습니다. 일관성은 데이터의 정확성과 적절성을 위한 목표라면 유효성 검사는 그 목표를 달성하기 위한 수단입니다.

### 격리성(Isolation)

동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않고 독립적으로 수행되어야 함을 의미합니다. 이는 동시성 문제를 방지하고 각 트랜잭션의 결과가 예측할 수 있게 합니다.

1. **트랜잭션 간 독립성**: 각 트랜잭션은 마치 독립적으로, 나아가 순차적으로 실행되는 것처럼 보이게 합니다.
2. **중간 결과 접근 제한**: 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없도록 합니다.
3. **격리 수준 설정**: DBMS에서 격리 수준을 설정할 수 있으며, 일반적으로 4가지 수준으로 분류됩니다.
4. **성능과 일관성의 균형**: 격리 수준을 높이면 데이터 일관성은 향상되지만, 동시성이 줄어들고, 반대로 격리 수준을 낮추면 동시성은 증가하지만 데이터 일관성 문제가 발생할 수 있습니다. 

![balance_performance_consistency.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/balance_performance_consistency.png?raw=true)

각 수준은 다양한 동시성 문제(Dirty Read, Non-Repeatable Read, Phantom Read)를 해결하며, 수준이 높아질수록 더 강력한 격리를 제공하지만 동시에 성능 저하가 발생할 수 있습니다.

### 지속성(Durability)

성공적으로 완료된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 데이터베이스에 반영되어야 함을 의미합니다. 

1. **영구적 보존**: 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템 장애나 전원 손실과 같은 예기치 않은 상황에서도 유지되어야 합니다.
2. **시스템 복구**: 데이터베이스 시스템은 장애 발생 시 데이터를 원래 상태로 복구할 수 있는 기능을 갖추어야 합니다.
3. **로그 기록**: 모든 트랜잭션은 로그에 기록되며, 이를 통해 시스템 장애 발생 전 상태로 되돌릴 수 있습니다.
4. **비휘발성 저장**: 트랜잭션의 결과는 비휘발성 저장 매체에 저장되어 시스템 재시작 후에도 유지됩니다.
5. **커밋 상태**: 트랜잭션은 모든 변경 사항이 로그에 저장된 후에만 커밋 상태로 간주합니다.

![durability_process.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/durability_process.png?raw=true)

위 예시는 **데이터베이스 로그 파일**에 트랜잭션 기록을 저장하는 방식을 보여줍니다. 커밋이 완료되면 변경 사항이 반드시 디스크에 기록되므로, 전원이 꺼져도 데이터가 보존됩니다.

실제 `지속성` 구현에서는 다음과 같은 기술이 사용됩니다.

- **Write-Ahead Logging(WAL)**: 모든 변경 사항을 로그에 먼저 기록하는 방식
- **체크포인트**: 주기적으로 메모리와 디스크 데이터를 동기화하는 방식
- **미러링/백업**: 다중 저장장치에 데이터 복제

이처럼 지속성은 데이터베이스의 신뢰성을 보장하는 중요한 특성으로, 사용자가 트랜잭션 완료 후 데이터의 영구적 저장을 신뢰할 수 있게 합니다.

## 트랜잭션 기능

✅트랜잭션에는 ACID의 속성 구현과 동시성 및 안정성 보장을 위한 핵심 메커니즘이 있습니다.

1. **Undo Log**:  
트랜잭션 중단 시 변경 사항을 이전 상태로 완전히 롤백 -> 원자성 보장
2. **Redo Log**:  
커밋된 트랜잭션 결과를 장애 발생 후에도 복구 -> 지속성 보장
3. **MVCC의 데이터 스냅샷**:  
트랜잭션 시작 시점의 **데이터 스냅샷**을 제공함으로써 다른 트랜잭션의 미완료 변경 사항을 숨김 -> 격리성 구현
4. **MVCC Non blocking Read 지원**:  
쓰기 작업이 읽기 작업을 차단하지 않음 -> 동시성 최적화 
5. **Commit**:  
모든 변경 사항을 최종 적용하고 잠금 해제 -> 원자성 완결  
Redo 로그를 디스크에 동기화 후 데이터 파일 업데이트 -> 지속성 확보 
6. **Rollback**:  
Undo 로그를 이용해 트랜잭션 시작 전 상태로 복구 -> 원자성 복구 
임시 버전 데이터 및 잠금 자동 해제 -> 자원 정리 
7. **Locking 메커니즘**: -> 격리성 강화   
베타 락(Exclusive Lock): 쓰기 작업 중 데이터 무결성 보호  
공유 락(Shared Lock): 읽기 일관성 유지  
**데드락 방지**: Lock 타임아웃 설정 또는 Wait-for 그래프 탐지 후 Victim 트랜잭션 롤백

|메커니즘|지원하는 ACID 속성|부가 기능|
|:--|:--|:--|
|로그 기법|원자성, 지속성|장애 복구|
|MVCC|격리성|동시성 향상|
|Locking|격리성|데드락 관리|
|Commit/Rollback|원자성, 지속성|트랜잭션 생명주기 제어| 

## 트랜잭션의 상태

트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위를 수행하는 과정에서 **5가지 주요 상태**을 거칩니다. 각 상태는 트랜잭션의 진행 상황과 결과를 나타내며, ACID 특성을 기반으로 데이터 무결성을 보장합니다.

![transaction_state.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/transaction_state.png?raw=true)

1. **활성(Active)**
    - 트랜잭션의 **모든 연산이 성공적으로 실행된 직후**의 상태
    - 커밋 요청이 발생했지만, 데이터베이스에 최종 반영되기 전 단계입니다. 시스템 장애 시 롤백될 수 있습니다.
2. **완료(Committed)**
    - 트랜잭션이 **성공적으로 종료**되고, 변경 사항이 **영구적으로 데이터베이스에 반영**된 상태 
    - 커밋 연산 실행 후 지속성(Durability)이 보장되며, 이후 다른 트랜잭션에서 결과를 참조할 수 있습니다.
3. **실패(Failed)**
    - 트랜잭션 실행 중 **오류가 발생**하여 중단된 상태. 예를 들어, 제약 조건 위반 또는 시스템 충돌로 인해 더 이상 진행할 수 없는 경우입니다.
4. **철회(Aborted)**
    - 실패한 트랜잭션이 **롤백 연산을 통해 이전 상태로 복구**된 상태
    - 트랜잭션 재시작 또는 폐기 여부가 결정되며, 데이터베이스는 트랜잭션 시작 전의 일관된 상태로 유지됩니다.

트랜잭션 상태 관리는 데이터 일관성 유지와 시스템 장애 시 복구에 필수적입니다. 각 상태의 명확한 이해는 신뢰성 높은 데이터베이스 운영의 기반이 됩니다.

## 마치며

트랜잭션은 데이터베이스 시스템에서 <span style="color:red">데이터의 일관성과 신뢰성을 보장</span>하는 핵심 메커니즘입니다. ACID 원칙을 통해 복잡한 데이터 처리 과정에서도 안정성을 유지할 수 있습니다.

트랜잭션의 다양한 상태와 기능들은 이러한 ACID 원칙을 실현하는 구체적인 방법을 제공합니다. Undo/Redo 로그, MVCC, 잠금 메커니즘 등의 기술은 트랜잭션의 안전한 실행과 복구를 가능하게 합니다. 

데이터베이스 관리자와 개발자들은 트랜잭션의 개념과 원리를 깊이 이해함으로써, 더 안정적이고 효율적인 데이터베이스 시스템을 설계하고 운영할 수 있습니다. 트랜잭션은 단순한 기술적 개념을 넘어, 데이터의 정확성과 비즈니스 로직의 무결성을 보장하는 중요한 도구입니다. 

앞으로 데이터의 중요성이 더욱 커지는 디지털 시대에, 트랜잭션에 대한 이해는 데이터 관리의 핵심 역량이 될 것입니다. 지속적인 학습과 실제 적용을 통해 트랜잭션의 강력한 기능을 최대한 활용하는 것이 중요합니다.