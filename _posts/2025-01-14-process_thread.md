---
title: "💬운영체제의 프로세스와 스레드의 개념"
date: 2025-01-14 12:08 +0900
categories: [CS]
tags: [process, thread]
---

> 프로세스와 스레드는 현대 컴퓨팅의 근간을 이루는 핵심 개념으로, 모든 개발자가 반드시 이해해야 합니다. 이들은 효율적인 프로그램 설계, 성능 최적화, 그리고 복잡한 시스템 구현의 기초가 됩니다. 프로세스와 스레드에 대한 깊이 있는 이해는 동시성 프로그래밍, 리소스 관리, 그리고 운영체제와의 상호작용을 더 잘 다룰 수 있게 해줍니다. 이 글에서는 프로세스와 스레드에 대해서 알아보겠습니다.

## 프로세스란?

프로세스는 실행 중인 프로그램을 의미합니다. 프로그램은 개발자들이 이미 개발해둔 코드 집합체라 보시면 됩니다. `exe, dmg` 파일 등이 프로그램에 속합니다. 이 프로그램을 실행하면 운영체제는 해당 프로그램을 위한 **프로세스와 프로세스 제어 블록(PCB)**이 만들어집니다. 이때 생성된 프로세스에 **메모리 공간을 할당**하고, 운영체제에서 **CPU를 할당(CPU 스케줄링)**하여 실행까지 이루어집니다. 

정리하자면, 운영체제가 프로그램 실행 시 생성된 프로세스에 CPU를 효율적으로 할당하며, 여러 프로세스와 함께 관리하는 것입니다. 프로세스가 어떻게 동작하는 지 자세히 알기 위해 구조, 특징, 상태에 대해 먼저 설명드린 후 동작과정에 대해 설명하겠습니다.

## 프로세스 구조

![process_structure.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/process_structure.png?raw=true)

프로세스의 구조는 일반적으로 코드, 데이터, 스택, 힙 영역으로 구성됩니다.

**📋스택 영역(Stack)**

스택 영역은 컴파일 시에 메모리 크기가 결정됩니다. 이는 정적 메모리 할당 방식을 사용하기 때문입니다. 스택에 저장되는 지역 변수, 매개 변수 등은 함수 호출 시 자동으로 할당되고 함수 종료 시 자동으로 해제됩니다. 

> 스택 영역은 일반적으로 정적 메모리 할당 방식을 사용하지만, 실행 중에 사용되는 크기는 동적으로 변할 수 있습니다. 

**📋힙 영역(Heap)**

힙 영역은 프로그램 실행 중에 동작으로 메모리가 할당됩니다. 프로그램 실행 중 필요에 따라 메모리를 할당하고 해제할 수 있습니다.

**📋코드 영역(Code Section)**

실행 가능한 프로그램 코드가 저장되는 영역으로 프로그램의 명령어들이 기계어 형태로 저장됩니다. 
CPU가 이 영역에서 명령어를 가져와 실행합니다.

**📋데이터 영역(Data Section)**

데이터 영역은 전역 변수와 정적(static) 변수가 저장되는 영역이며 프로그램 시작 시 할당되어 프로그램 종료 시까지 유지됩니다. 종류는 초기화된 데이터와 초기화되지 않은 데이터로 나뉩니다. 

- 초기화된 데이터: GVAR(Global Variable) 영역에 저장
- 초기화되지 않은 데이터: BBS(Block Started by Symbol) 영역에 저장

> 프로세스는 위와 같은 구조로 운영체제로부터 독립적인 메모리 공간과 시스템 자원을 할당받습니다.

**📋프로세스 제어 블록(PCB)**

위에서 프로세스를 생성하면 프로세스 제어 블록(PCB)가 같이 만들어진다 했습니다. PCB는 자료 구조로 담당하는 프로세스를 관리하는 역활을 합니다. PCB에는 프로세스 ID, 상태, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보 등이 포함되며 자세한 역활은 프로세스 동작과정에서 설명하겠습니다.

## 프로세스의 생명주기

프로세스의 생명주기를 설명하기 전이 상태에 대해서 먼저 설명하겠습니다. 

|상태|설명|
|:--|:--|
|생성(New)|프로세스가 메모리에 로드되어 초기화되는 단계입니다.|
|준비(Ready)|CPU할당을 기다리는 상태입니다. 준비 큐에서 대기합니다.|
|실행(Running)|CPU를 할당받아 명령어를 실행하는 상태입니다.|
|대기(Waiting)|I/O 작업 등으로 인해 CPU를 사용하지 않고 특정 이벤트를 기다리는 상태입니다.|
|종료(Terminated)|프로세스 실행이 완료되어 시스템에서 제거되는 상태입니다.|

프로세스는 이러한 상태들 사이를 전이하며 생명 주기를 거칩니다. 

![process_lifecycle.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/process_lifecycle.png?raw=true)

1️⃣ Admitted(승인): 새로 생성된 프로세스가 준비 상태로 전환되는 과정입니다.

2️⃣ Dispatch(디스패치): 준비 상태의 프로세스가 실행 상태로 전환되는 과정입니다. CPU 스케줄러에 의해 선택된 프로세스가 CPU를 할당받아 실행됩니다. 

3️⃣ Interrupt(인터럽트): 실행 중인 프로세스가 예기치 않은 이벤트나 타임아웃으로 인해 준비 상태로 전환되는 과정입니다. 

4️⃣ I/O or event wait(입출력 또는 이벤트 대기): 실행 중인 프로세스가 입출력 작업이나 특정 이벤트를 기다리기 위해 대기 상태로 전환되는 과정입니다. 

5️⃣ I/O or event completion(입출력 또는 이벤트 완료): 대기 상태의 프로세스가 기다리던 입출력 작업이나 이벤트가 완료되어 다시 준비 상태로 전환되는 과정입니다. 

## 프로세스 컨텍스트 스위칭(Context Switching) 

프로세스 생명주기의 설명을 보면 조금 이상한 점이 있습니다. 바로 실행해서 종료한다면 좋을 텐데 왜 굳이 대기와 이벤트가 있을까요? 이는 운영체제가 여러 프로세스를 동시에 실행하는 것처럼 보이기 위해서입니다. 저희가 컴퓨터에서 크롬을 사용하면서 게임도 하고, 동영상 재생도 할 수 있는 이유가 여기에 있습니다. 만약 프로세스를 실행하고 종료한다면 하고 있는 걸 종료하거나, 다운을 다 받고 나서 다음 작업을 할 수 있습니다. 이처럼 프로세스를 동시에 실행하는 것처럼 보이게 하는 것 뿐만 아니라 시스템의 효율성, 성능, 응답성 등을 높이기 위한 필수적인 형태가 프로세스 생명주기의 형태입니다. 

프로세스 생명주기를 활용하여 위의 효과를 얻기 위해선 프로세스 컨텍스트 스위칭이 필요합니다. 이는 운영체제에서 CPU가 한 프로세스에서 다른 프로세스로 전환하는 과정을 말합니다. 과정은 다음과 같습니다.

![process_scheduler.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/process_scheduler.png?raw=true)

그림을 간략히 설명하자면 ❶실행 중인 프로세스가 나오게 되면 ❷해당 PCB가 프로세스의 상태(레지스터 값, 프로그램 카운터 등)을 저장하고, 프로세스는 준비 또는 대기 큐로 이동합니다. ❸다음으로 올 프로세스를 CPU 스케줄러가 선택하면 ❹선택된 프로세스의 PCB를 갱신하고 해당 프로세스의 상태를 복원(Reload)합니다. ❺상태 복원이 완료되면 해당 프로세스를 시작합니다.

컨텍스트 스위칭을 통해 운영체제가 여러 프로세스를 동시에 실행하는 것처럼 보이게 하는 멀티태스킹의 기능을 할 수 있습니다. 즉, 하나의 CPU가 여러 프로세스를 공유할 수 있게 합니다. 또한, CPU 자원을 효율적으로 사용할 수 있고, 사용자 입력이나 시스템 이벤트에 빠르게 대응할 수 있습니다. 

> 이외에도 컨텍스트 스위칭은 다양한 알고리즘을 통해 여러 프로세스에 공정하게 CPU 시간을 할당할 수 있습니다. 또한 프로세스 간 격리를 제공하여 한 프로세스의 오류가 전체 시스템에 영향을 미치지 않도록 하여 안정성과 신뢰성을 높이는 역활을 합니다.

## 프로세스 컨텍스트 스위칭 오버헤드(Context Switching Overhead) 

컨텍스트 스위칭 동작과정 그림에서 P1과 P2 실행 사이에 프로세스를 변경하기 위한 간극이 발생합니다. 이는 PCB를 저장하고 불러오는 것도 원인이지만 다음과 같은 이유들이 있습니다.

**직접적 오버헤드**

- CPU 시간 소비: 현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태를 복원하는 데 CPU 시간이 소요됩니다.
- 메모리 작업: PCB 정보를 메모리에 저장하고 로드하는 과정에서 메모리 접근 시간이 필요합니다.

**간접적 오버헤드**

- 캐시 무효화: 프로세스가 전환될 때 캐시 메모리의 내용이 무효화되어 캐시 미스가 발생합니다.(상당한 성능 저하의 원인)
- TLB 플러시: 페이지 테이블이 변경되면서 TLB(Translation Lookaside Buffer)를 비우고 다시 채워야 합니다.
- 파이프라인 플러시: CPU 파이프라인이 비워지면서 실행 지연이 발생합니다.

이러한 컨텍스트 스위칭 오버헤드는 시스템의 성능 저하를 초래하며 이러한 오버헤드를 최소화하기 위해 효율적인 스케줄링 알고리즘이 필요합니다. 

## 프로세스의 한계

운영체제에서 프로세스는 독립적인 실행 단위로 동작하지만, 몇가지 중요한 한계점을 가지고 있습니다. 

1. 높은 컨텍스트 스위칭 비용:  
컨텍스트 스위칭의 과정에서 오버헤드가 발생하여 상당한 시스템 자원과 시간을 소비하게 됩니다.
2. 무거운 프로세스 생성 비용:  
새로운 프로세스를 생성할 때마다 독립적인 메모리 공간 할당이 필요합니다. 코드, 데이터, 힙 영역 등 모든 자원을 새로 할당해야 합니다.
3. 복잡한 프로세스 간 통신:  
프로세스들은 독립적인 메모리 공간을 가지므로, 프로세스 간 통신(IPC)을 위해서는 복잡한 메커니즘이 필요합니다. 

> 이러한 프로세스의 한계를 극복하기 위해 스레드가 등장했습니다. 스레드는 프로세스의 장점을 유지하면서 한계점을 보완하여, 현대 운영체제에서 효율적인 병렬 처리를 가능하게 만들었습니다. 아래에서 스레드에 대해 더 알아보겠습니다.

## 스레드란?


![os_process_thread_structure.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/os_process_thread_structure.png?raw=true)


스레드는 프로세스 내에서 실행되는 작업의 단위입니다. 프로세스가 실행 중인 프로그램이라면, 스레드는 그 프로그램 내에서 실제로 작업을 수행하는 주체입니다. 프로세스는 최소 하나 이상의 스레드를 가집니다.

이러한 스레드는 프로세스의 한계점을 보안하기 위해 나왔습니다. 스레드는 프로세스 내의 메모리를 공유하며, 각 스레드는 독립적인 스택과 레지스터를 가집니다. 이러한 특징으로 다음과 같은 장점이 있습니다.

**✅스레드의 특징**

1. 메모리 절약: 프로세스에 비해 훨씬 적은 메모리를 사용합니다.
2. 응답성 향상: 다른 부분이 블로킹되어도 프로그램의 수행이 계속될 수 있습니다.
3. 자원 공유: 같은 프로세스 내의 스레드들은 자원을 공유하여 효율적으로 작업할 수 있습니다.

## 프로세스와 스레드의 차이점

스레드와 프로세스의 공통점과 차이점을 보면 더 많은 장점이 있습니다. 

**✅프로세스와 스레드 공통점**

1. **실행 단위**: 둘 다 컴퓨터에서 실행되는 작업의 단위입니다. 
2. **상태 변화**: 프로세스와 마찬가지고 스레드도 준비, 실행, 대기, 종료 상태를 가집니다.
3. **스케줄링**: 프로세스와 스레드 모두 운영체제의 스케줄링 대상이 됩니다.
4. **병렬 실행**: 여러 개의 독립적인 프로세스가 동시에 실행되고, 스레드는 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행됩니다.
5. **컨텍스트 스위칭**: 프로세스 간 전환과 스레드 간 전환 모두 컨텍스트 스위칭이 발생합니다.
6. **독립적 실행**: 각 프로세스와 스레드는 독립적인 실행 순서를 가집니다.

**✅프로세스와 스레드 차이점**

1. **메모리 공유**  
    - 프로세스: 각 프로세스는 독립된 메모리 공간(코드, 데이터, 스택, 힙)을 할당받습니다.
    - 스레드: 같은 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유하고 스택만 따로 할당받습니다.
2. **자원 할당** 
    - 프로세스: 운영체제로부터 직접 자원을 할당받는 작업의 단위입니다.
    - 스레드: 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다.
3. 통신 방식  
    - 프로세스: 프로세스 간 통신(IPC)을 사용해야 합니다.
    - 스레드: 같은 프로세스 내 스레드 간 통신이 더 쉽고 빠릅니다.
4. 생성 및 종료 속도
    - 프로세스: 생성과 종료에 더 많은 시간이 소요됩니다.
    - 스레드: 같은 프로세스 내 스레드 간 통신이 더 쉽고 빠릅니다.
5. **컨텍스트 스위칭**
    - 프로세스: 컨텍스트 스위칭 비용이 큽니다.
    - 스레드: 프로세스보다 컨텍스트 스위칭 비용이 작습니다.
6. **안정성**
    - 프로세스: 하나의 프로세스가 중단되어도 다른 프로세스에 영향을 주지 않습니다.
    - 스레드: 하나의 스레드에 문제가 생기면 같은 프로세스 내 다른 스레드들도 영향을 받을 수 있습니다.

> 이러한 차이점들로 인해, 스레드는 자원을 효율적으로 사용하고 응답 시간을 개선할 수 있지만, 자원을 공유하는 곳에서 동기화 문제에 주의해야 합니다. 반면 프로세스는 안정성이 높지만 자원 사용이 더 많고 프로세스 간 통신이 복잡합니다.

## 스레드의 스케줄링 

스레드 스케줄링은 운영체제가 **하나의 프로세스 내의 스레드들 사이**에서 CPU 시간을 어떻게 분배할지 결정하는 과정입니다. 스레드 스케줄링에 사용되는 알고리즘은 프로세스 스케줄링과 유사한 알고리즘을 가집니다. 스레드의 우선 순위, 시간 등을 고려한 알고리즘들이 있습니다. 이 글에서는 종류만 간단히 보고 다른 글에서 스케줄링에 대해 다루겠습니다.

1. 라운드 로빈(Round Robin, RR)
2. 우선순위 기반(Priority-Based)
3. 최소 남은 시간 우선(Shortest Remaining Time First, SRTF)

다만 스레드는 안정성 면에서 프로세스에 비해 하나의 스레드에 문제가 생기면 같은 프로세스 내 다른 스레드들도 영향을 받을 수 있습니다. 그리고 하나의 프로세스에 다수의 스레드가 있으므로 스레드 간의 동기화 문제를 신경써야 합니다.

## 스레드의 생명주기 

스레드의 생명주기는 다음과 같은 주요 상태로 구성됩니다. 

|성태|설명|
|:--|:--|
|생성(New)|스레드가 생성되었지만 아직 실행되지 않은 초기 상태입니다.|
|실행 가능(Runnable)|스레드가 실행될 준비가 된 상태입니다.|
|실행(Running)|스레드가 CPU를 할당받아 실제로 작업을 수행하는 상태입니다.|
|일시 정지(Blocked)|스레드가 실행 중 동기화된 블록이나 메소드에 진입하기 위해 락(lock)을 획득하려고 대기하는 상태입니다.|
|대기(Waiting)|스레드가 다른 스레드의 특정 작업이 끝나기를 기다리는 상태입니다.|
|시간 제한 대기(Timed_Waiting)|대기 상태와 유사하지만, 지정된 시간 동안만 대기하는 상태입니다.|
|종료(Terminated)|스레드의 실행이 완료되었거나 강제로 중지된 상태입니다.|

