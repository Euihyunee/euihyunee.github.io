---
title: "💬운영체제의 프로세스와 스레드의 개념"
date: 2025-01-14 12:08 +0900
categories: [CS]
tags: [process, thread]
---

> 프로세스와 스레드는 현대 컴퓨팅의 근간을 이루는 핵심 개념으로, 모든 개발자가 반드시 이해해야 합니다. 이들은 효율적인 프로그램 설계, 성능 최적화, 그리고 복잡한 시스템 구현의 기초가 됩니다. 프로세스와 스레드에 대한 깊이 있는 이해는 동시성 프로그래밍, 리소스 관리, 그리고 운영체제와의 상호작용을 더 잘 다룰 수 있게 해줍니다. 이 글에서는 프로세스와 스레드에 대해서 알아보겠습니다.

## 프로세스란?

프로세스는 실행 중인 프로그램을 의미합니다. 프로그램은 개발자들이 이미 개발해둔 코드 집합체라 보시면 됩니다. `exe, dmg` 파일 등이 프로그램에 속합니다. 이 프로그램을 실행하면 운영체제는 해당 프로그램을 위한 **프로세스와 프로세스 제어 블록(PCB)**이 만들어집니다. 이때 생성된 프로세스에 **메모리 공간을 할당**하고, 운영체제에서 **CPU를 할당(CPU 스케줄링)**하여 실행까지 이루어집니다. 

정리하자면, 운영체제가 프로그램 실행 시 생성된 프로세스에 CPU를 효율적으로 할당하며, 여러 프로세스와 함께 관리하는 것입니다. 프로세스가 어떻게 동작하는 지 자세히 알기 위해 구조, 특징, 상태에 대해 먼저 설명드린 후 동작과정에 대해 설명하겠습니다.

## 병렬성과 동시성

프로세스와 스레드에서 병렬성과 동시성은 다양한 상황에서 활용됩니다. 각각의 개념이 어떤 곳에서 사용되는지 살펴 보겠습니다.

**병렬성(Parakkekusm)은 여러 작업을 실제로 동시에 수행하는 것**을 의미합니다. 물리적인 영역이며 CPU 코어 개수만큼 작업을 동시에 할 수 있다고 생각하시면 됩니다. 여러 컴퓨터에 걸쳐 프로세스를 분산시켜 대규모 병렬 처리를 수행하는 **분산 컴퓨팅** 같은 곳에서 활용할 수 있습니다. 

**동시성(Concurrency)**은 여러 작업이 동시에 진행되는 것처럼 보이지만, 실제로는 빠르게 번갈아가며 실행되는 것을 의미합니다. 이는 컴퓨터에서 여러 개의 프로그램을 동시에 실행하는 것처럼 보이게 하는 멀티태스킹의 주요 개념입니다. 우리가 웹 브라우저, 문서 편집기 등 여러 프로그램을 동시에 실행할 수 있는 이유입니다. 그런데 왜 번갈아가면서 실행시키는 지 설명하도록 하겠습니다. 

첫 번째로, 하드웨어적 한계가 있습니다. 아무리 기술이 발전해도 물리적으로 CPU에 탑재할 수 있는 코어의 수에는 한계가 있습니다. 1000개의 프로그램을 실행하기 위해서 1000개의 코어를 다는 것은 무리가 있습니다. 또한 CPU의 발열과 하드웨어의 자원을 효율적으로 활용하기 위해 동시성이 필요합니다. 

두 번째로, 논리적인 효율이 있습니다. 여러 작업을 잘게 나누어 번갈아 가며 처리함으로써, 시스템의 전반적인 반응성과 효율성을 높일 수 있습니다. 예시로 단순히 긴 작업과 짧은 작업이 순서대로 들어왔을 때, 긴 작업 때문에 짧은 작업이 오래 기다리는 상황을 방지할 수 있습니다. 또한 사용자 입장에서 한 작업이 오래 걸려 다른 작업이 안 되는 상황을 방지함으로써, 사용자에게 더 빠른 반응성을 제공할 수 있습니다. 

![ex_concurrency.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/ex_concurrency.png?raw=true)

결론적으로, 병렬성은 물리적인 하드웨어면에서 동시에 여러 작업을 처리하여 성능을 극대화하는 데 사용되며, 동시성은 이러한 하드웨어의 제한된 자원을 효율적으로 활용하고 시스템의 반응성을 높이는 데 중요한 역할을 합니다. 두 개념은 상호 보완적으로 사용되어 현대의 복잡한 컴퓨팅 환경에서 최적의 성능과 사용자 경험을 제공합니다.

프로세스와 스레드는 병렬성과 동시성을 구현하는 핵심 메커니즘입니다. 프로세스는 독립적인 메모리 공간을 가지며 주로 병렬성을 활용한 대규모 작업에 사용되고, 스레드는 같은 프로세스 내에서 메모리를 공유하며 동시성을 구현하는 데 효과적입니다. 이 두 가지를 적절히 활용함으로써, 시스템은 효율적인 자원 관리와 향상된 성능을 달성할 수 있습니다.

## 프로세스 구조

![process_structure.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/process_structure.png?raw=true)

프로세스의 구조는 일반적으로 코드, 데이터, 스택, 힙 영역으로 구성됩니다.

**📋스택 영역(Stack)**

스택 영역은 컴파일 시에 메모리 크기가 결정됩니다. 이는 정적 메모리 할당 방식을 사용하기 때문입니다. 스택에 저장되는 지역 변수, 매개 변수 등은 함수 호출 시 자동으로 할당되고 함수 종료 시 자동으로 해제됩니다. 

> 스택 영역은 일반적으로 정적 메모리 할당 방식을 사용하지만, 실행 중에 사용되는 크기는 동적으로 변할 수 있습니다. 

**📋힙 영역(Heap)**

힙 영역은 프로그램 실행 중에 동작으로 메모리가 할당됩니다. 프로그램 실행 중 필요에 따라 메모리를 할당하고 해제할 수 있습니다.

**📋코드 영역(Code Section)**

실행 가능한 프로그램 코드가 저장되는 영역으로 프로그램의 명령어들이 기계어 형태로 저장됩니다. 
CPU가 이 영역에서 명령어를 가져와 실행합니다.

**📋데이터 영역(Data Section)**

데이터 영역은 전역 변수와 정적(static) 변수가 저장되는 영역이며 프로그램 시작 시 할당되어 프로그램 종료 시까지 유지됩니다. 종류는 초기화된 데이터와 초기화되지 않은 데이터로 나뉩니다. 

- 초기화된 데이터: GVAR(Global Variable) 영역에 저장
- 초기화되지 않은 데이터: BBS(Block Started by Symbol) 영역에 저장

> 프로세스는 위와 같은 구조로 운영체제로부터 독립적인 메모리 공간과 시스템 자원을 할당받습니다.

**📋프로세스 제어 블록(PCB)**

위에서 프로세스를 생성하면 프로세스 제어 블록(PCB)가 같이 만들어진다 했습니다. PCB는 자료 구조로 담당하는 프로세스를 관리하는 역활을 합니다. PCB에는 프로세스 ID, 상태, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보 등이 포함되며 자세한 역활은 프로세스 동작과정에서 설명하겠습니다.

## 프로세스의 생명주기

프로세스의 생명주기를 설명하기 전이 상태에 대해서 먼저 설명하겠습니다. 

|상태|설명|
|:--|:--|
|생성(New)|프로세스가 메모리에 로드되어 초기화되는 단계입니다.|
|준비(Ready)|CPU할당을 기다리는 상태입니다. 준비 큐에서 대기합니다.|
|실행(Running)|CPU를 할당받아 명령어를 실행하는 상태입니다.|
|대기(Waiting)|I/O 작업 등으로 인해 CPU를 사용하지 않고 특정 이벤트를 기다리는 상태입니다.|
|종료(Terminated)|프로세스 실행이 완료되어 시스템에서 제거되는 상태입니다.|

프로세스는 이러한 상태들 사이를 전이하며 생명 주기를 거칩니다. 

![process_lifecycle.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/process_lifecycle.png?raw=true)

1️⃣ Admitted(승인): 새로 생성된 프로세스가 준비 상태로 전환되는 과정입니다.

2️⃣ Dispatch(디스패치): 준비 상태의 프로세스가 실행 상태로 전환되는 과정입니다. CPU 스케줄러에 의해 선택된 프로세스가 CPU를 할당받아 실행됩니다. 

3️⃣ Interrupt(인터럽트): 실행 중인 프로세스가 예기치 않은 이벤트나 타임아웃으로 인해 준비 상태로 전환되는 과정입니다. 

4️⃣ I/O or event wait(입출력 또는 이벤트 대기): 실행 중인 프로세스가 입출력 작업이나 특정 이벤트를 기다리기 위해 대기 상태로 전환되는 과정입니다. 

5️⃣ I/O or event completion(입출력 또는 이벤트 완료): 대기 상태의 프로세스가 기다리던 입출력 작업이나 이벤트가 완료되어 다시 준비 상태로 전환되는 과정입니다. 

## 프로세스 컨텍스트 스위칭(Context Switching) 

프로세스 생명주기의 설명을 보면 조금 이상한 점이 있습니다. 바로 실행해서 종료한다면 좋을 텐데 왜 굳이 대기와 이벤트가 있을까요? 이는 운영체제가 여러 프로세스를 동시에 실행하는 것처럼 보이기 위해서입니다. 저희가 컴퓨터에서 크롬을 사용하면서 게임도 하고, 동영상 재생도 할 수 있는 이유가 여기에 있습니다. 만약 프로세스를 실행하고 종료한다면 하고 있는 걸 종료하거나, 다운을 다 받고 나서 다음 작업을 할 수 있습니다. 이처럼 프로세스를 동시에 실행하는 것처럼 보이게 하는 것 뿐만 아니라 시스템의 효율성, 성능, 응답성 등을 높이기 위한 필수적인 형태가 프로세스 생명주기의 형태입니다. 

프로세스 생명주기를 활용하여 위의 효과를 얻기 위해선 프로세스 컨텍스트 스위칭이 필요합니다. 이는 운영체제에서 CPU가 한 프로세스에서 다른 프로세스로 전환하는 과정을 말합니다. 과정은 다음과 같습니다.

![process_scheduler.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/process_scheduler.png?raw=true)

그림을 간략히 설명하자면 ❶실행 중인 프로세스가 나오게 되면 ❷해당 PCB가 프로세스의 상태(레지스터 값, 프로그램 카운터 등)을 저장하고, 프로세스는 준비 또는 대기 큐로 이동합니다. ❸다음으로 올 프로세스를 CPU 스케줄러가 선택하면 ❹선택된 프로세스의 PCB를 갱신하고 해당 프로세스의 상태를 복원(Reload)합니다. ❺상태 복원이 완료되면 해당 프로세스를 시작합니다.

컨텍스트 스위칭을 통해 운영체제가 여러 프로세스를 동시에 실행하는 것처럼 보이게 하는 멀티태스킹의 기능을 할 수 있습니다. 즉, 하나의 CPU가 여러 프로세스를 공유할 수 있게 합니다. 또한, CPU 자원을 효율적으로 사용할 수 있고, 사용자 입력이나 시스템 이벤트에 빠르게 대응할 수 있습니다. 

> 이외에도 컨텍스트 스위칭은 다양한 알고리즘을 통해 여러 프로세스에 공정하게 CPU 시간을 할당할 수 있습니다. 또한 프로세스 간 격리를 제공하여 한 프로세스의 오류가 전체 시스템에 영향을 미치지 않도록 하여 안정성과 신뢰성을 높이는 역활을 합니다.

## 프로세스 컨텍스트 스위칭 오버헤드(Context Switching Overhead) 

컨텍스트 스위칭 동작과정 그림에서 P1과 P2 실행 사이에 프로세스를 변경하기 위한 간극이 발생합니다. 이는 PCB를 저장하고 불러오는 것도 원인이지만 다음과 같은 이유들이 있습니다.

**직접적 오버헤드**

- CPU 시간 소비: 현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태를 복원하는 데 CPU 시간이 소요됩니다.
- 메모리 작업: PCB 정보를 메모리에 저장하고 로드하는 과정에서 메모리 접근 시간이 필요합니다.

**간접적 오버헤드**

- 캐시 무효화: 프로세스가 전환될 때 캐시 메모리의 내용이 무효화되어 캐시 미스가 발생합니다.(상당한 성능 저하의 원인)
- TLB 플러시: 페이지 테이블이 변경되면서 TLB(Translation Lookaside Buffer)를 비우고 다시 채워야 합니다.
- 파이프라인 플러시: CPU 파이프라인이 비워지면서 실행 지연이 발생합니다.

이러한 컨텍스트 스위칭 오버헤드는 시스템의 성능 저하를 초래하며 이러한 오버헤드를 최소화하기 위해 효율적인 스케줄링 알고리즘이 필요합니다. 

## 프로세스의 한계

운영체제에서 프로세스는 독립적인 실행 단위로 동작하지만, 몇가지 중요한 한계점을 가지고 있습니다. 

1. 높은 컨텍스트 스위칭 비용:  
컨텍스트 스위칭의 과정에서 오버헤드가 발생하여 상당한 시스템 자원과 시간을 소비하게 됩니다.
2. 무거운 프로세스 생성 비용:  
새로운 프로세스를 생성할 때마다 독립적인 메모리 공간 할당이 필요합니다. 코드, 데이터, 힙 영역 등 모든 자원을 새로 할당해야 합니다.
3. 복잡한 프로세스 간 통신:  
프로세스들은 독립적인 메모리 공간을 가지므로, 프로세스 간 통신(IPC)을 위해서는 복잡한 메커니즘이 필요합니다. 

> 이러한 프로세스의 한계를 극복하기 위해 스레드가 등장했습니다. 스레드는 프로세스의 장점을 유지하면서 한계점을 보완하여, 현대 운영체제에서 효율적인 병렬 처리를 가능하게 만들었습니다. 아래에서 스레드에 대해 더 알아보겠습니다.

## 스레드란?


![os_process_thread_structure.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/os_process_thread_structure.png?raw=true)


스레드는 프로세스 내에서 실행되는 작업의 단위입니다. 프로세스가 실행 중인 프로그램이라면, 스레드는 그 프로그램 내에서 실제로 작업을 수행하는 주체입니다. 프로세스는 최소 하나 이상의 스레드를 가집니다.

이러한 스레드는 프로세스의 한계점을 보안하기 위해 나왔습니다. 스레드는 프로세스 내의 메모리를 공유하며, 각 스레드는 독립적인 스택과 레지스터를 가집니다. 이러한 특징으로 다음과 같은 장점이 있습니다.

**✅스레드의 특징**

1. 메모리 절약: 프로세스에 비해 훨씬 적은 메모리를 사용합니다.
2. 응답성 향상: 다른 부분이 블로킹되어도 프로그램의 수행이 계속될 수 있습니다.
3. 자원 공유: 같은 프로세스 내의 스레드들은 자원을 공유하여 효율적으로 작업할 수 있습니다.

## 프로세스와 스레드의 차이점

스레드와 프로세스의 공통점과 차이점을 보면 더 많은 장점이 있습니다. 

**✅프로세스와 스레드 공통점**

1. **실행 단위**: 둘 다 컴퓨터에서 실행되는 작업의 단위입니다. 
2. **상태 변화**: 프로세스와 마찬가지고 스레드도 준비, 실행, 대기, 종료 상태를 가집니다.
3. **스케줄링**: 프로세스와 스레드 모두 운영체제의 스케줄링 대상이 됩니다.
4. **병렬 실행**: 여러 개의 독립적인 프로세스가 동시에 실행되고, 스레드는 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행됩니다.
5. **컨텍스트 스위칭**: 프로세스 간 전환과 스레드 간 전환 모두 컨텍스트 스위칭이 발생합니다.
6. **독립적 실행**: 각 프로세스와 스레드는 독립적인 실행 순서를 가집니다.

**✅프로세스와 스레드 차이점**

1. **메모리 공유**  
    - 프로세스: 각 프로세스는 독립된 메모리 공간(코드, 데이터, 스택, 힙)을 할당받습니다.
    - 스레드: 같은 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유하고 스택만 따로 할당받습니다.
2. **자원 할당** 
    - 프로세스: 운영체제로부터 직접 자원을 할당받는 작업의 단위입니다.
    - 스레드: 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다.
3. 통신 방식  
    - 프로세스: 프로세스 간 통신(IPC)을 사용해야 합니다.
    - 스레드: 같은 프로세스 내 스레드 간 통신이 더 쉽고 빠릅니다.
4. 생성 및 종료 속도
    - 프로세스: 생성과 종료에 더 많은 시간이 소요됩니다.
    - 스레드: 같은 프로세스 내 스레드 간 통신이 더 쉽고 빠릅니다.
5. **컨텍스트 스위칭**
    - 프로세스: 컨텍스트 스위칭 비용이 큽니다.
    - 스레드: 프로세스보다 컨텍스트 스위칭 비용이 작습니다.
6. **안정성**
    - 프로세스: 하나의 프로세스가 중단되어도 다른 프로세스에 영향을 주지 않습니다.
    - 스레드: 하나의 스레드에 문제가 생기면 같은 프로세스 내 다른 스레드들도 영향을 받을 수 있습니다.

> 이러한 차이점들로 인해, 스레드는 자원을 효율적으로 사용하고 응답 시간을 개선할 수 있지만, 자원을 공유하는 곳에서 동기화 문제에 주의해야 합니다. 반면 프로세스는 안정성이 높지만 자원 사용이 더 많고 프로세스 간 통신이 복잡합니다.

## 스레드의 스케줄링 

스레드 스케줄링은 운영체제가 **하나의 프로세스 내의 스레드들 사이**에서 CPU 시간을 어떻게 분배할지 결정하는 과정입니다. 스레드 스케줄링에 사용되는 알고리즘은 프로세스 스케줄링과 유사한 알고리즘을 가집니다. 스레드의 우선 순위, 시간 등을 고려한 알고리즘들이 있습니다. 이 글에서는 종류만 간단히 보고 다른 글에서 스케줄링에 대해 다루겠습니다.

1. 라운드 로빈(Round Robin, RR)
2. 우선순위 기반(Priority-Based)
3. 최소 남은 시간 우선(Shortest Remaining Time First, SRTF)

다만 스레드는 안정성 면에서 프로세스에 비해 하나의 스레드에 문제가 생기면 같은 프로세스 내 다른 스레드들도 영향을 받을 수 있습니다. 그리고 하나의 프로세스에 다수의 스레드가 있으므로 스레드 간의 동기화 문제를 신경써야 합니다.

## 스레드의 생명주기 

스레드의 생명주기는 다음과 같은 주요 상태로 구성됩니다. 

|상태|설명|
|:--|:--|
|생성(New)|스레드가 생성되었지만 아직 실행되지 않은 초기 상태입니다.|
|실행 가능(Runnable)|스레드가 실행될 준비가 된 상태입니다.|
|실행(Running)|스레드가 CPU를 할당받아 실제로 작업을 수행하는 상태입니다.|
|일시 정지(Blocked)|스레드가 실행 중 동기화된 블록이나 메소드에 진입하기 위해 락(lock)을 획득하려고 대기하는 상태입니다.|
|대기(Waiting)|스레드가 다른 스레드의 특정 작업이 끝나기를 기다리는 상태입니다.|
|시간 제한 대기(Timed_Waiting)|대기 상태와 유사하지만, 지정된 시간 동안만 대기하는 상태입니다.|
|종료(Terminated)|스레드의 실행이 완료되었거나 강제로 중지된 상태입니다.|

![thread_lifecycle.png](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/thread_lifecycle.png?raw=true)

위 그림을 보시면 스레드의 생명주기는 프로세스의 생명주기와 매우 유사하게 작동합니다. 스레드와 프로세스 모두 CPU에 의해 실행되는 작업 단위이며, 스케줄링 알고리즘 또한 서로 유사합니다. 따라서 상태 전이도 서로 유사한 모습을 보입니다. 하지만 메모리, 자원 할당 등에서 차이가 있습니다. 다음과 같은 차이점이 있습니다. 

1. 메모리 공유: 프로세스는 독립된 메모리 공간을 가지지만, 스레드는 같은 프로세스 내의 다른 스레드와 코드, 데이터, 힙 영역을 공유합니다.
2. 생성 및 종료 비용: 스레드는 프로세스보다 생성과 종료가 더 빠르고 경제적입니다.
3. 자원 할당: 프로세스는 운영체제로부터 직접 자원을 할당받지만, 스레드는 자신이 속한 프로세스의 자원을 이용합니다. 
4. 독립성: 프로세스는 다른 프로세스와 독립적이지만, 스레드는 같은 프로세스 내의 다른 스레드와 밀접하게 연관되어 있습니다.
5. 오류 전파: 한 프로세스의 오류는 다른 프로세스에 영향을 주지 않지만, 한 스레드의 오류는 같은 프로세스 내의 다른 스레드에 영향을 줄 수 있습니다.

결론적으로, 스레드의 동작 방식은 프로세스와 유사한 점이 있지만, 메모리 공유, 자원 할당, 독립성 등에서 중요한 차이가 있습니다. 이러한 차이점으로 인해 스레드는 프로세스보다 더 가볍고 효율적인 동시성 모델을 제공할 수 있습니다. 

## 스레드 컨텍스트 스위칭 

스레드 컨텍스트 스위칭(Thread context switching)은 CPU에서 실행 중인 스레드를 다른 스레드로 교체하는 과정입니다. 프로세스 컨텍스트 스위칭은 PCB를 쓰는 반면, 스레드 컨텍스트 스위칭에서는 TCB(Thread Control Block)을 사용하여 스레드의 상태를 저장하거나 복원합니다. 

**📋TCB 블록**

TCB(Thread Control Block)는 운영체제에서 스레드를 관리하기 위해 사용하는 자료구조입니다. 각 스레드마다 고유한 TCB가 생성되며, 스레드의 실행에 필요한 중요한 정보들을 저장합니다. 

스레드는 프로세스 내의 자원을 공유하므로 TCB는 PCB보다 적은 정보를 저장합니다. PCB는 프로세스의 전반적인 정보를 저장하는 반면, TCB는 스레드 고유의 정보(스레드 ID, 스레드 상태, 스택 포인터, 프로그램 카운터 등) 스레드 실행에 필요한 정보만 포함합니다. 또한 프로세스보다 빠른 컨텍스트 스위칭을 합니다. 

다만, 프로세스와 달리 메모리와 자원을 공유하기에 동기화 작업이 필요합니다. 적절한 동기화 없이는 경쟁 조건, 데드락, 기아 현상 등의 문제가 발생할 수 있기 때문이다. TCB에는 스레드 간 동기화에 필요한 정보를 TCB에 저장하여 관리합니다. 스레드 동기화를 함으로써 데이터 무결성과 일관성을 유지할 수 있습니다.

> 스레드의 동기화는 주로 뮤텍스, 세마포어, 모니터 등을 사용합니다. 프로세스에서도 다른 프로세스 간의 동기화가 있지만 이는 자원 공유를 위한 것입니다. 주로 IPC(Inter-Process Communication) 메커니즘을 사용합니다.
> - 뮤텍스(Mutex): 상호 배제를 위한 기본적인 동기화 도구로, 한 번에 하나의 스레드만 접근을 허용합니다.
> - 세마포어(Semaphore): 여러 스레드의 동시 접근을 제어하는 카운터 기반의 동기화 도구입니다.
> - 모니터(Monitor): 상호 배제와 조건 동기화를 결합한 고수준의 동기화 메커니즘입니다.

## 마치며 

프로세스와 스레드는 현대 운영체제에서 병렬성과 동시성을 구현하는 핵심 메커니즘입니다.
프로세스는 독립적인 메모리 공간과 자원을 가지며, 안정성이 높고 다른 프로세스의 영향을 받지 않는 장점이 있습니다. 그러나 생성 및 컨텍스트 스위칭 비용이 크고, 프로세스 간 통신이 복잡합니다.

반면 스레드는 같은 프로세스 내에서 메모리와 자원을 공유하여 더 효율적이고 빠른 실행이 가능합니다. 스레드 생성과 컨텍스트 스위칭 비용이 적어 응답성이 향상되고, 스레드 간 통신이 용이합니다. 그러나 한 스레드의 문제가 전체 프로세스에 영향을 줄 수 있어 동기화에 주의가 필요합니다.

결론적으로, 프로세스와 스레드는 각각의 장단점을 가지고 있으며, 상황에 따라 적절히 선택하여 사용해야 합니다. 대규모 독립적 작업에는 프로세스가, 가벼운 병렬 작업이나 빈번한 데이터 공유가 필요한 경우에는 스레드가 더 적합할 수 있습니다. 두 개념을 효과적으로 활용함으로써 시스템의 성능, 효율성, 그리고 사용자 경험을 최적화할 수 있습니다.

다음 글에서는 멀티 프로세스와 멀티 스레드에 대해 설명하겠습니다. 