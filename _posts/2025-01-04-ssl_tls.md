---
title: 💬SSL/TLS란? (작성중)
date: 2025-01-03 16:45 +0900
categories: [CS]
tags: [SSL, TLS, ]
---

## SSL/TLS 소개 

HTTPS에서 마지막의 S는 Over Secure Socket Layer의 약자로 보안이 강화된 HTTP입니다. SSL/TLS 기반으로 동작하여 HTTPS 통신을 위한 암호화 및 인증 메커니즘을 제공합니다.  
우리가 접근하는 웹 사이트가 https://~ 로 시작한다면, 웹 서버의 보안이 강화되어 데이터 통신이 안정적으로 전달됨을 의미합니다.  

![no_https](![graphql_logo](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/no_https.png?raw=true))

#### SSL? TLS 뭐가 다른걸까?

SSL(Secure Sockets Layer)와 TLS(Transport Layer Secyrity)는 뭐가 다를까요? 

**같다고 봐도 무방**합니다. TLS는 SSL의 이름이 바뀐 것입니다. 당시 Netscape와 Microsoft 간에 웹의 우위를 위한 싸움이 있었습니다. Microsoft를 위해 SSL 프로토콜 이름이 TLS로 변경되었습니다. 

> 이 글에서는 편의상 TLS라 부르겠습니다. 

#### TLS의 중요성

TLS는 현재 가장 널리 사용되는 네트워크 보안 프로토콜입니다. TLS는 OSI 모델의 응용 계층과 전송 계층 사이에서 작동하며 다음과 같은 보안 기능을 제공합니다. 

- 데이터 암호화 : 클라이언트와 서버 간의 통신을 암호화하여 데이터의 기밀성을 보장합니다. 
- 인증 : 통신 당사자의 신원을 확인하여 중간자 공격을 방지합니다. 
- 데이터 무결성 : 전송 중 데이터의 변조를 방지하고 탐지합니다. 

## TLS의 작동 원리

TLS 프로토콜은 인터넷 통신의 보안을 위해 `대칭키`와 `비대칭키 암호화` 방식을 모두 사용합니다. 이 두방식의 장점을 결합하여 안전하고 효율적인 통신을 가능하게 합니다. 

#### 대칭키 암호화 

대칭키 암호화는 암호화와 복호화에 동일한 키를 사용하며 특징은 다음과 같습니다. 

- 암호화와 복호화에 같은 키를 사용
- 빠른 처리 속도
- 키의 길이가 상대적으로 짧음
- 구현이 쉬움

**장점**
- 암호화 및 복호화 속도가 빠름
- 대량의 데이터 처리에 적합

#### 비대칭키 암호화

비대칭키 암호화는 공개키와 개인키라는 두 개의 서로 다른 키를 사용하는 방식이며 특징은 다음과 같습니다. 

- 암호화와 복호화에 서로 다른 키를 사용
- 공개키는 누구나 알 수 있지만, 개인키는 소유자만 알아야 함 
- 처리 속도가 대칭키에 비해 느림

**장점**
- 안전한 키 교환 가능
- 인증과 암호화를 동시에 수행 가능
- 다수 사용자 간 통신에 효과적


#### TLS 핸드셰이크 과정

TLS(Transport Layer Security) 핸드셰이크 단계는 클라이언트와 서버 간에 전송되는 데이터그램 또는 메시지로 구성됩니다. 

> 통신에 사용할 암호화 알고리즘에 따라 TLS 핸드셰이크 과정이 달라집니다.
{: .prompt-info }

과정의 단계는 다음과 같습니다. 


![tls_handshake](![graphql_logo](https://github.com/Euihyunee/euihyunee.github.io/blob/main/_posts/img/tls_handshake.png?raw=true))

1. ClientHello : 클라이언트가 서버에 연결을 시도합니다. 이 메시지에는 클라이언트가 지원하는 TLS 버전, 암호화 알고리즘 목록, 그리고 "클라이언트 랜덤"이라고 불리는 임의의 바이트 문자열이 포함됩니다. 
2. ServerHello : 서버는 클라이언트가 제안한 옵션 중에서 사용할 TLS 버전과 암호화 알고리즘을 선택하여 응답합니다. 또한 "서버 랜덤"이라는 또 다른 임의의 바이트 문자열을 전송합니다. 
3. Certificate : 서버는 자신의 디지털 인증서를 클라이언트에게 전송합니다. 인증서는 서버의 공개키, 도메인 정보, 인증 기관(CA) 정보 등이 포함되며 `CA의 개인키(비대칭키)`로 서명되어 있습니다.
4. ServerKeyExchange : 서버의 인증서에 키 교환에 필요한 정보가 부족한 경우, 서버는 추가적인 정보(ex: Diffie-Hellman 파라미터)를 전송합니다. -> `공개키(비대칭키)` 
5. CertificateRequest : 선택적 단계로, 서버가 클라이언트 인증을 요구할 경우 이 메시지를 보냅니다.
6. ServerHelloDone : 서버가 초기 핸드셰이크 메시지 전송을 완료했음을 알립니다.
7. Certificate : 서버가 클라이언트 인증을 요청한 경우, 클라이언트는 자신의 인증서를 전송합니다. -> `클라이언트의 공개키(비대칭키)` 
8. ClientKeyExchange : 클라이언트는 세션 키 생성에 사용될 "FreeMaster Secret"을 생성하고, 이를 서버의 공개 키로 암호화하여 전송합니다. -> `비대칭키`
9. CertificateVerify : 클라이언트 인증이 요청된 경우, 클라이언트는 자신의 개인 키로 서명한 핸드셰이크 메시지의 해시를 전송합니다. -> `비대칭키`
10. ChangeCipherSpec : 클라이언트가 이후의 모든 메시지를 협상된 세션 키로 암호화할 것임을 알립니다.
11. Finished : 클라이언트는 지금까지의 핸드셰이크 메시지에 대한 해시를 암호화하여 전송합니다. -> `대칭키` 협상된 세션 키로 암호화된 핸드셰이크 메시지 해시 전송
12. ChangeCipherSpec : 서버도 이후의 모든 메시지를 세션 키로 암호화할 것임을 알립니다. -> `대킹키` 협상된 세션 키로 암호화된 핸드셰이크 메시지 해시 전송 
13. Finished : 서버는 핸드셰이크 메시지의 해시를 암호화하여 전송합니다. -> `대칭키` 협상된 세션 키를 사용하여 모든 후속 통신 암호화 
14. 암호화된 애플리케이션 데이터 : 핸드셰이크가 완료되면, 클라이언트와 서버는 협상된 세션 키를 사용하여 안전하게 데이터를 주고받습니다. -> `대칭키` 협상된 세션 키를 사용하여 모든 후속 통신 암호화

이 과정을 통해 TLS는 초기에 비대칭키 암호화를 사용하여 안전하게 키를 교환한 후, 실제 데이터 통신에는 더 효율적인 대칭키 암호화를 사용합니다. 


## TLS 관련 취약점과 대응책

TLS는 인터넷 통신의 보안을 위해 사용되는 프로토콜이지만, 취약점과 한계점이 존재합니다. 이 글에서 간단하게 살펴보겠습니다. 

주요 TLS 취약점으로는 POODLE, BEAST, CRIME, Heartbleed, Lucky 13 등이 있으며, 이들은 주로 오래된 TLS 버전이나 잘못된 구현에서 발생합니다. 이러한 취약점들은 암호화된 데이터의 해독, 민감한 정보 유출, 중간자 공격 등을 가능하게 만들어 심각한 보안 위협이 될 수 있습니다.  

또한 TLS은 높은 지연 시간, 구형 시스템과의 호환성 문제, 최신 TLS 1.3버전에 대한 제한적인 지원 등의 이유로 어쩔 수 없는 한계점이 존재합니다. 보안과 한계점들을 해결하기 위해서 강력한 암호 스위트를 선택하고, 정기적인 보안 업데이트와 취약점 스캔 등을 수행해야합니다. 하지만 레거시 시스템과의 호환성 유지, 업그레이드에 따른 비용 문제 등의 문제로 완전한 보안 강화에 어려움이 있습니다. 

TLS 취약점 관리는 다른 보안 정책들에 비해 더 높은 우선순위를 가지기 때문에, 이에 대한 관리는 필수적입니다.

#### 마치며

이상으로 TLS가 동작하는 과정에 대해 살펴보고, 어떤 취약점과 한계점이 있는지 살펴보았습니다.  
TLS는 현대 웹 보안에서 중요한 위치에 자리잡고 있습니다. 전자 상거래, 온라인 뱅킹, 이메일 등 민감한 정보를 다루는 모든 온라인 서비스에서 필수적입니다. 다음에는 TLS의 설정 방법에 대해 소개드리겠습니다. 